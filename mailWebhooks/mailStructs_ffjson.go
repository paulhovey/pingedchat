// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: mailWebhooks/mailStructs.go
// DO NOT EDIT!

package mailWebhooks

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *MandrillWebHookContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MandrillWebHookContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"ts":`)
	fflib.FormatBits2(buf, uint64(mj.Ts), 10, false)
	buf.WriteString(`,"event":`)
	fflib.WriteJsonString(buf, string(mj.Event))
	buf.WriteString(`,"msg":`)

	{

		err = mj.Msg.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MandrillWebHookContentbase = iota
	ffj_t_MandrillWebHookContentno_such_key

	ffj_t_MandrillWebHookContent_Ts

	ffj_t_MandrillWebHookContent_Event

	ffj_t_MandrillWebHookContent_Msg
)

var ffj_key_MandrillWebHookContent_Ts = []byte("ts")

var ffj_key_MandrillWebHookContent_Event = []byte("event")

var ffj_key_MandrillWebHookContent_Msg = []byte("msg")

func (uj *MandrillWebHookContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MandrillWebHookContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MandrillWebHookContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MandrillWebHookContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_MandrillWebHookContent_Event, kn) {
						currentKey = ffj_t_MandrillWebHookContent_Event
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MandrillWebHookContent_Msg, kn) {
						currentKey = ffj_t_MandrillWebHookContent_Msg
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_MandrillWebHookContent_Ts, kn) {
						currentKey = ffj_t_MandrillWebHookContent_Ts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookContent_Msg, kn) {
					currentKey = ffj_t_MandrillWebHookContent_Msg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebHookContent_Event, kn) {
					currentKey = ffj_t_MandrillWebHookContent_Event
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookContent_Ts, kn) {
					currentKey = ffj_t_MandrillWebHookContent_Ts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MandrillWebHookContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MandrillWebHookContent_Ts:
					goto handle_Ts

				case ffj_t_MandrillWebHookContent_Event:
					goto handle_Event

				case ffj_t_MandrillWebHookContent_Msg:
					goto handle_Msg

				case ffj_t_MandrillWebHookContentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ts:

	/* handler: uj.Ts type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Ts = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Event:

	/* handler: uj.Event type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Event = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Msg:

	/* handler: uj.Msg type=mailWebhooks.MandrillWebHookMessage kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Msg.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MandrillWebHookMessage) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MandrillWebHookMessage) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"raw_msg":`)
	fflib.WriteJsonString(buf, string(mj.RawMsg))
	buf.WriteString(`,"headers":`)

	{

		err = mj.Headers.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"text":`)
	fflib.WriteJsonString(buf, string(mj.Text))
	buf.WriteString(`,"html":`)
	fflib.WriteJsonString(buf, string(mj.Html))
	buf.WriteString(`,"from_email":`)
	fflib.WriteJsonString(buf, string(mj.FromEmail))
	buf.WriteString(`,"from_name":`)
	fflib.WriteJsonString(buf, string(mj.FromName))
	buf.WriteString(`,"to":`)
	if mj.To != nil {
		buf.WriteString(`[`)
		for i, v := range mj.To {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}
					fflib.WriteJsonString(buf, string(v))
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"email":`)
	fflib.WriteJsonString(buf, string(mj.Email))
	buf.WriteString(`,"subject":`)
	fflib.WriteJsonString(buf, string(mj.Subject))
	buf.WriteString(`,"tags":`)
	if mj.Tags != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Tags {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"sender":`)
	fflib.WriteJsonString(buf, string(mj.Sender))
	if mj.TextFlowed {
		buf.WriteString(`,"text_flowed":true`)
	} else {
		buf.WriteString(`,"text_flowed":false`)
	}
	buf.WriteString(`,"attachments":`)
	/* Falling back. type=map[string]mailWebhooks.MandrillWebhookAttachment kind=map */
	err = buf.Encode(mj.Attachments)
	if err != nil {
		return err
	}
	buf.WriteString(`,"images":`)
	if mj.Images != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Images {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"spam_report":`)

	{

		err = mj.SpamReport.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"dkim":`)

	{

		err = mj.Dkim.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"spf":`)

	{

		err = mj.Spf.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MandrillWebHookMessagebase = iota
	ffj_t_MandrillWebHookMessageno_such_key

	ffj_t_MandrillWebHookMessage_RawMsg

	ffj_t_MandrillWebHookMessage_Headers

	ffj_t_MandrillWebHookMessage_Text

	ffj_t_MandrillWebHookMessage_Html

	ffj_t_MandrillWebHookMessage_FromEmail

	ffj_t_MandrillWebHookMessage_FromName

	ffj_t_MandrillWebHookMessage_To

	ffj_t_MandrillWebHookMessage_Email

	ffj_t_MandrillWebHookMessage_Subject

	ffj_t_MandrillWebHookMessage_Tags

	ffj_t_MandrillWebHookMessage_Sender

	ffj_t_MandrillWebHookMessage_TextFlowed

	ffj_t_MandrillWebHookMessage_Attachments

	ffj_t_MandrillWebHookMessage_Images

	ffj_t_MandrillWebHookMessage_SpamReport

	ffj_t_MandrillWebHookMessage_Dkim

	ffj_t_MandrillWebHookMessage_Spf
)

var ffj_key_MandrillWebHookMessage_RawMsg = []byte("raw_msg")

var ffj_key_MandrillWebHookMessage_Headers = []byte("headers")

var ffj_key_MandrillWebHookMessage_Text = []byte("text")

var ffj_key_MandrillWebHookMessage_Html = []byte("html")

var ffj_key_MandrillWebHookMessage_FromEmail = []byte("from_email")

var ffj_key_MandrillWebHookMessage_FromName = []byte("from_name")

var ffj_key_MandrillWebHookMessage_To = []byte("to")

var ffj_key_MandrillWebHookMessage_Email = []byte("email")

var ffj_key_MandrillWebHookMessage_Subject = []byte("subject")

var ffj_key_MandrillWebHookMessage_Tags = []byte("tags")

var ffj_key_MandrillWebHookMessage_Sender = []byte("sender")

var ffj_key_MandrillWebHookMessage_TextFlowed = []byte("text_flowed")

var ffj_key_MandrillWebHookMessage_Attachments = []byte("attachments")

var ffj_key_MandrillWebHookMessage_Images = []byte("images")

var ffj_key_MandrillWebHookMessage_SpamReport = []byte("spam_report")

var ffj_key_MandrillWebHookMessage_Dkim = []byte("dkim")

var ffj_key_MandrillWebHookMessage_Spf = []byte("spf")

func (uj *MandrillWebHookMessage) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MandrillWebHookMessage) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MandrillWebHookMessagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MandrillWebHookMessageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_Attachments, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Attachments
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_Dkim, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Dkim
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_Email, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Email
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_FromEmail, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_FromEmail
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebHookMessage_FromName, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_FromName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_Headers, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Headers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebHookMessage_Html, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Html
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_Images, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Images
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_RawMsg, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_RawMsg
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_Subject, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Subject
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebHookMessage_Sender, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Sender
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebHookMessage_SpamReport, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_SpamReport
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebHookMessage_Spf, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Spf
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_MandrillWebHookMessage_Text, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Text
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebHookMessage_To, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_To
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebHookMessage_Tags, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_Tags
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebHookMessage_TextFlowed, kn) {
						currentKey = ffj_t_MandrillWebHookMessage_TextFlowed
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_Spf, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Spf
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_Dkim, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Dkim
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_SpamReport, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_SpamReport
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_Images, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Images
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_Attachments, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Attachments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MandrillWebHookMessage_TextFlowed, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_TextFlowed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_Sender, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Sender
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_Tags, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Tags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_Subject, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Subject
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebHookMessage_Email, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebHookMessage_To, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_To
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MandrillWebHookMessage_FromName, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_FromName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MandrillWebHookMessage_FromEmail, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_FromEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebHookMessage_Html, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Html
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebHookMessage_Text, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_Headers, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_Headers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebHookMessage_RawMsg, kn) {
					currentKey = ffj_t_MandrillWebHookMessage_RawMsg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MandrillWebHookMessageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MandrillWebHookMessage_RawMsg:
					goto handle_RawMsg

				case ffj_t_MandrillWebHookMessage_Headers:
					goto handle_Headers

				case ffj_t_MandrillWebHookMessage_Text:
					goto handle_Text

				case ffj_t_MandrillWebHookMessage_Html:
					goto handle_Html

				case ffj_t_MandrillWebHookMessage_FromEmail:
					goto handle_FromEmail

				case ffj_t_MandrillWebHookMessage_FromName:
					goto handle_FromName

				case ffj_t_MandrillWebHookMessage_To:
					goto handle_To

				case ffj_t_MandrillWebHookMessage_Email:
					goto handle_Email

				case ffj_t_MandrillWebHookMessage_Subject:
					goto handle_Subject

				case ffj_t_MandrillWebHookMessage_Tags:
					goto handle_Tags

				case ffj_t_MandrillWebHookMessage_Sender:
					goto handle_Sender

				case ffj_t_MandrillWebHookMessage_TextFlowed:
					goto handle_TextFlowed

				case ffj_t_MandrillWebHookMessage_Attachments:
					goto handle_Attachments

				case ffj_t_MandrillWebHookMessage_Images:
					goto handle_Images

				case ffj_t_MandrillWebHookMessage_SpamReport:
					goto handle_SpamReport

				case ffj_t_MandrillWebHookMessage_Dkim:
					goto handle_Dkim

				case ffj_t_MandrillWebHookMessage_Spf:
					goto handle_Spf

				case ffj_t_MandrillWebHookMessageno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_RawMsg:

	/* handler: uj.RawMsg type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.RawMsg = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Headers:

	/* handler: uj.Headers type=mailWebhooks.MandrillWebhookHeaders kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Headers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: uj.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Html:

	/* handler: uj.Html type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Html = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FromEmail:

	/* handler: uj.FromEmail type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromEmail = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FromName:

	/* handler: uj.FromName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_To:

	/* handler: uj.To type=[][]string kind=slice quoted=false*/

	{
		/* Falling back. type=[][]string kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.To)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Subject:

	/* handler: uj.Subject type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Subject = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tags:

	/* handler: uj.Tags type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Tags = nil
		} else {

			uj.Tags = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Tags = append(uj.Tags, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sender:

	/* handler: uj.Sender type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Sender = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TextFlowed:

	/* handler: uj.TextFlowed type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.TextFlowed = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.TextFlowed = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attachments:

	/* handler: uj.Attachments type=map[string]mailWebhooks.MandrillWebhookAttachment kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Attachments = nil
		} else {

			uj.Attachments = make(map[string]MandrillWebhookAttachment, 0)

			wantVal := true

			for {

				var k string

				var v MandrillWebhookAttachment

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: v type=mailWebhooks.MandrillWebhookAttachment kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Attachments[k] = v

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Images:

	/* handler: uj.Images type=[]mailWebhooks.MandrillWebhookAttachment kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Images = nil
		} else {

			uj.Images = make([]MandrillWebhookAttachment, 0)

			wantVal := true

			for {

				var v MandrillWebhookAttachment

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=mailWebhooks.MandrillWebhookAttachment kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Images = append(uj.Images, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SpamReport:

	/* handler: uj.SpamReport type=mailWebhooks.MandrillWebhookSpamReport kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.SpamReport.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Dkim:

	/* handler: uj.Dkim type=mailWebhooks.MandrillWebhookDkim kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Dkim.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spf:

	/* handler: uj.Spf type=mailWebhooks.MandrillWebhookSpf kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spf.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MandrillWebhookAttachment) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MandrillWebhookAttachment) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"content":`)
	fflib.WriteJsonString(buf, string(mj.Content))
	if mj.IsBase64 {
		buf.WriteString(`,"base64":true`)
	} else {
		buf.WriteString(`,"base64":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MandrillWebhookAttachmentbase = iota
	ffj_t_MandrillWebhookAttachmentno_such_key

	ffj_t_MandrillWebhookAttachment_Name

	ffj_t_MandrillWebhookAttachment_Type

	ffj_t_MandrillWebhookAttachment_Content

	ffj_t_MandrillWebhookAttachment_IsBase64
)

var ffj_key_MandrillWebhookAttachment_Name = []byte("name")

var ffj_key_MandrillWebhookAttachment_Type = []byte("type")

var ffj_key_MandrillWebhookAttachment_Content = []byte("content")

var ffj_key_MandrillWebhookAttachment_IsBase64 = []byte("base64")

func (uj *MandrillWebhookAttachment) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MandrillWebhookAttachment) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MandrillWebhookAttachmentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MandrillWebhookAttachmentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_MandrillWebhookAttachment_IsBase64, kn) {
						currentKey = ffj_t_MandrillWebhookAttachment_IsBase64
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_MandrillWebhookAttachment_Content, kn) {
						currentKey = ffj_t_MandrillWebhookAttachment_Content
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_MandrillWebhookAttachment_Name, kn) {
						currentKey = ffj_t_MandrillWebhookAttachment_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_MandrillWebhookAttachment_Type, kn) {
						currentKey = ffj_t_MandrillWebhookAttachment_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookAttachment_IsBase64, kn) {
					currentKey = ffj_t_MandrillWebhookAttachment_IsBase64
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookAttachment_Content, kn) {
					currentKey = ffj_t_MandrillWebhookAttachment_Content
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookAttachment_Type, kn) {
					currentKey = ffj_t_MandrillWebhookAttachment_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookAttachment_Name, kn) {
					currentKey = ffj_t_MandrillWebhookAttachment_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MandrillWebhookAttachmentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MandrillWebhookAttachment_Name:
					goto handle_Name

				case ffj_t_MandrillWebhookAttachment_Type:
					goto handle_Type

				case ffj_t_MandrillWebhookAttachment_Content:
					goto handle_Content

				case ffj_t_MandrillWebhookAttachment_IsBase64:
					goto handle_IsBase64

				case ffj_t_MandrillWebhookAttachmentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: uj.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsBase64:

	/* handler: uj.IsBase64 type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.IsBase64 = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.IsBase64 = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MandrillWebhookDkim) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MandrillWebhookDkim) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.Signed {
		buf.WriteString(`{"signed":true`)
	} else {
		buf.WriteString(`{"signed":false`)
	}
	if mj.Valid {
		buf.WriteString(`,"valid":true`)
	} else {
		buf.WriteString(`,"valid":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MandrillWebhookDkimbase = iota
	ffj_t_MandrillWebhookDkimno_such_key

	ffj_t_MandrillWebhookDkim_Signed

	ffj_t_MandrillWebhookDkim_Valid
)

var ffj_key_MandrillWebhookDkim_Signed = []byte("signed")

var ffj_key_MandrillWebhookDkim_Valid = []byte("valid")

func (uj *MandrillWebhookDkim) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MandrillWebhookDkim) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MandrillWebhookDkimbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MandrillWebhookDkimno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffj_key_MandrillWebhookDkim_Signed, kn) {
						currentKey = ffj_t_MandrillWebhookDkim_Signed
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_MandrillWebhookDkim_Valid, kn) {
						currentKey = ffj_t_MandrillWebhookDkim_Valid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookDkim_Valid, kn) {
					currentKey = ffj_t_MandrillWebhookDkim_Valid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookDkim_Signed, kn) {
					currentKey = ffj_t_MandrillWebhookDkim_Signed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MandrillWebhookDkimno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MandrillWebhookDkim_Signed:
					goto handle_Signed

				case ffj_t_MandrillWebhookDkim_Valid:
					goto handle_Valid

				case ffj_t_MandrillWebhookDkimno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Signed:

	/* handler: uj.Signed type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Signed = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Signed = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Valid:

	/* handler: uj.Valid type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Valid = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Valid = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MandrillWebhookHeaders) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MandrillWebhookHeaders) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Content-Type":`)
	fflib.WriteJsonString(buf, string(mj.ContentType))
	buf.WriteString(`,"Date":`)
	fflib.WriteJsonString(buf, string(mj.Date))
	buf.WriteString(`,"Dkim-Signature":`)
	fflib.WriteJsonString(buf, string(mj.DkimSignature))
	buf.WriteString(`,"Domainkey-Signature":`)
	fflib.WriteJsonString(buf, string(mj.DomainKeySignature))
	buf.WriteString(`,"From":`)
	fflib.WriteJsonString(buf, string(mj.From))
	buf.WriteString(`,"List-Unsubscribe":`)
	fflib.WriteJsonString(buf, string(mj.ListUnsubscribe))
	buf.WriteString(`,"Message-Id":`)
	fflib.WriteJsonString(buf, string(mj.MessageId))
	buf.WriteString(`,"Mime-Version":`)
	fflib.WriteJsonString(buf, string(mj.MimeVersion))
	buf.WriteString(`,"Received":`)
	if mj.Received != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Received {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Sender":`)
	fflib.WriteJsonString(buf, string(mj.Sender))
	buf.WriteString(`,"Subject":`)
	fflib.WriteJsonString(buf, string(mj.Subject))
	buf.WriteString(`,"To":`)
	fflib.WriteJsonString(buf, string(mj.To))
	buf.WriteString(`,"X-Report-Abuse":`)
	fflib.WriteJsonString(buf, string(mj.XReportAbuse))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MandrillWebhookHeadersbase = iota
	ffj_t_MandrillWebhookHeadersno_such_key

	ffj_t_MandrillWebhookHeaders_ContentType

	ffj_t_MandrillWebhookHeaders_Date

	ffj_t_MandrillWebhookHeaders_DkimSignature

	ffj_t_MandrillWebhookHeaders_DomainKeySignature

	ffj_t_MandrillWebhookHeaders_From

	ffj_t_MandrillWebhookHeaders_ListUnsubscribe

	ffj_t_MandrillWebhookHeaders_MessageId

	ffj_t_MandrillWebhookHeaders_MimeVersion

	ffj_t_MandrillWebhookHeaders_Received

	ffj_t_MandrillWebhookHeaders_Sender

	ffj_t_MandrillWebhookHeaders_Subject

	ffj_t_MandrillWebhookHeaders_To

	ffj_t_MandrillWebhookHeaders_XReportAbuse
)

var ffj_key_MandrillWebhookHeaders_ContentType = []byte("Content-Type")

var ffj_key_MandrillWebhookHeaders_Date = []byte("Date")

var ffj_key_MandrillWebhookHeaders_DkimSignature = []byte("Dkim-Signature")

var ffj_key_MandrillWebhookHeaders_DomainKeySignature = []byte("Domainkey-Signature")

var ffj_key_MandrillWebhookHeaders_From = []byte("From")

var ffj_key_MandrillWebhookHeaders_ListUnsubscribe = []byte("List-Unsubscribe")

var ffj_key_MandrillWebhookHeaders_MessageId = []byte("Message-Id")

var ffj_key_MandrillWebhookHeaders_MimeVersion = []byte("Mime-Version")

var ffj_key_MandrillWebhookHeaders_Received = []byte("Received")

var ffj_key_MandrillWebhookHeaders_Sender = []byte("Sender")

var ffj_key_MandrillWebhookHeaders_Subject = []byte("Subject")

var ffj_key_MandrillWebhookHeaders_To = []byte("To")

var ffj_key_MandrillWebhookHeaders_XReportAbuse = []byte("X-Report-Abuse")

func (uj *MandrillWebhookHeaders) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MandrillWebhookHeaders) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MandrillWebhookHeadersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MandrillWebhookHeadersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_ContentType, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_ContentType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_Date, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_Date
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebhookHeaders_DkimSignature, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_DkimSignature
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebhookHeaders_DomainKeySignature, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_DomainKeySignature
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_From, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_From
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_ListUnsubscribe, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_ListUnsubscribe
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_MessageId, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_MessageId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebhookHeaders_MimeVersion, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_MimeVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_Received, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_Received
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_Sender, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_Sender
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MandrillWebhookHeaders_Subject, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_Subject
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_To, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_To
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'X':

					if bytes.Equal(ffj_key_MandrillWebhookHeaders_XReportAbuse, kn) {
						currentKey = ffj_t_MandrillWebhookHeaders_XReportAbuse
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookHeaders_XReportAbuse, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_XReportAbuse
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookHeaders_To, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_To
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookHeaders_Subject, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_Subject
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookHeaders_Sender, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_Sender
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookHeaders_Received, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_Received
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookHeaders_MimeVersion, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_MimeVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookHeaders_MessageId, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_MessageId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookHeaders_ListUnsubscribe, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_ListUnsubscribe
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookHeaders_From, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_From
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookHeaders_DomainKeySignature, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_DomainKeySignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookHeaders_DkimSignature, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_DkimSignature
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookHeaders_Date, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_Date
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MandrillWebhookHeaders_ContentType, kn) {
					currentKey = ffj_t_MandrillWebhookHeaders_ContentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MandrillWebhookHeadersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MandrillWebhookHeaders_ContentType:
					goto handle_ContentType

				case ffj_t_MandrillWebhookHeaders_Date:
					goto handle_Date

				case ffj_t_MandrillWebhookHeaders_DkimSignature:
					goto handle_DkimSignature

				case ffj_t_MandrillWebhookHeaders_DomainKeySignature:
					goto handle_DomainKeySignature

				case ffj_t_MandrillWebhookHeaders_From:
					goto handle_From

				case ffj_t_MandrillWebhookHeaders_ListUnsubscribe:
					goto handle_ListUnsubscribe

				case ffj_t_MandrillWebhookHeaders_MessageId:
					goto handle_MessageId

				case ffj_t_MandrillWebhookHeaders_MimeVersion:
					goto handle_MimeVersion

				case ffj_t_MandrillWebhookHeaders_Received:
					goto handle_Received

				case ffj_t_MandrillWebhookHeaders_Sender:
					goto handle_Sender

				case ffj_t_MandrillWebhookHeaders_Subject:
					goto handle_Subject

				case ffj_t_MandrillWebhookHeaders_To:
					goto handle_To

				case ffj_t_MandrillWebhookHeaders_XReportAbuse:
					goto handle_XReportAbuse

				case ffj_t_MandrillWebhookHeadersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContentType:

	/* handler: uj.ContentType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ContentType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: uj.Date type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Date = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DkimSignature:

	/* handler: uj.DkimSignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.DkimSignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DomainKeySignature:

	/* handler: uj.DomainKeySignature type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.DomainKeySignature = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: uj.From type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.From = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ListUnsubscribe:

	/* handler: uj.ListUnsubscribe type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ListUnsubscribe = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageId:

	/* handler: uj.MessageId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MessageId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeVersion:

	/* handler: uj.MimeVersion type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MimeVersion = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Received:

	/* handler: uj.Received type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Received = nil
		} else {

			uj.Received = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Received = append(uj.Received, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sender:

	/* handler: uj.Sender type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Sender = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Subject:

	/* handler: uj.Subject type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Subject = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_To:

	/* handler: uj.To type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.To = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_XReportAbuse:

	/* handler: uj.XReportAbuse type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.XReportAbuse = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MandrillWebhookSpamReport) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MandrillWebhookSpamReport) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"score":`)
	fflib.AppendFloat(buf, float64(mj.Score), 'g', -1, 32)
	buf.WriteString(`,"matched_rules":`)
	if mj.MatchedRules != nil {
		buf.WriteString(`[`)
		for i, v := range mj.MatchedRules {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Inline struct. type=struct { Name string "json:\"name\""; Description string "json:\"description\""; Score float32 "json:\"score\""; Spf struct { Result string "json:\"result\""; Detail string "json:\"detail\"" } "json:\"spf,omitempty\"" } kind=struct */
			buf.WriteString(`{ "name":`)
			fflib.WriteJsonString(buf, string(v.Name))
			buf.WriteString(`,"description":`)
			fflib.WriteJsonString(buf, string(v.Description))
			buf.WriteString(`,"score":`)
			fflib.AppendFloat(buf, float64(v.Score), 'g', -1, 32)
			buf.WriteByte(',')
			if true {
				/* Inline struct. type=struct { Result string "json:\"result\""; Detail string "json:\"detail\"" } kind=struct */
				buf.WriteString(`"spf":{ "result":`)
				fflib.WriteJsonString(buf, string(v.Spf.Result))
				buf.WriteString(`,"detail":`)
				fflib.WriteJsonString(buf, string(v.Spf.Detail))
				buf.WriteByte('}')
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MandrillWebhookSpamReportbase = iota
	ffj_t_MandrillWebhookSpamReportno_such_key

	ffj_t_MandrillWebhookSpamReport_Score

	ffj_t_MandrillWebhookSpamReport_MatchedRules
)

var ffj_key_MandrillWebhookSpamReport_Score = []byte("score")

var ffj_key_MandrillWebhookSpamReport_MatchedRules = []byte("matched_rules")

func (uj *MandrillWebhookSpamReport) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MandrillWebhookSpamReport) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MandrillWebhookSpamReportbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MandrillWebhookSpamReportno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffj_key_MandrillWebhookSpamReport_MatchedRules, kn) {
						currentKey = ffj_t_MandrillWebhookSpamReport_MatchedRules
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_MandrillWebhookSpamReport_Score, kn) {
						currentKey = ffj_t_MandrillWebhookSpamReport_Score
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookSpamReport_MatchedRules, kn) {
					currentKey = ffj_t_MandrillWebhookSpamReport_MatchedRules
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookSpamReport_Score, kn) {
					currentKey = ffj_t_MandrillWebhookSpamReport_Score
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MandrillWebhookSpamReportno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MandrillWebhookSpamReport_Score:
					goto handle_Score

				case ffj_t_MandrillWebhookSpamReport_MatchedRules:
					goto handle_MatchedRules

				case ffj_t_MandrillWebhookSpamReportno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Score:

	/* handler: uj.Score type=float32 kind=float32 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Score = float32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MatchedRules:

	/* handler: uj.MatchedRules type=[]struct { Name string "json:\"name\""; Description string "json:\"description\""; Score float32 "json:\"score\""; Spf struct { Result string "json:\"result\""; Detail string "json:\"detail\"" } "json:\"spf,omitempty\"" } kind=slice quoted=false*/

	{
		/* Falling back. type=[]struct { Name string "json:\"name\""; Description string "json:\"description\""; Score float32 "json:\"score\""; Spf struct { Result string "json:\"result\""; Detail string "json:\"detail\"" } "json:\"spf,omitempty\"" } kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.MatchedRules)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MandrillWebhookSpf) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MandrillWebhookSpf) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"detail":`)
	fflib.WriteJsonString(buf, string(mj.Detail))
	buf.WriteString(`,"result":`)
	fflib.WriteJsonString(buf, string(mj.Result))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MandrillWebhookSpfbase = iota
	ffj_t_MandrillWebhookSpfno_such_key

	ffj_t_MandrillWebhookSpf_Detail

	ffj_t_MandrillWebhookSpf_Result
)

var ffj_key_MandrillWebhookSpf_Detail = []byte("detail")

var ffj_key_MandrillWebhookSpf_Result = []byte("result")

func (uj *MandrillWebhookSpf) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MandrillWebhookSpf) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MandrillWebhookSpfbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MandrillWebhookSpfno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_MandrillWebhookSpf_Detail, kn) {
						currentKey = ffj_t_MandrillWebhookSpf_Detail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_MandrillWebhookSpf_Result, kn) {
						currentKey = ffj_t_MandrillWebhookSpf_Result
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MandrillWebhookSpf_Result, kn) {
					currentKey = ffj_t_MandrillWebhookSpf_Result
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MandrillWebhookSpf_Detail, kn) {
					currentKey = ffj_t_MandrillWebhookSpf_Detail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MandrillWebhookSpfno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MandrillWebhookSpf_Detail:
					goto handle_Detail

				case ffj_t_MandrillWebhookSpf_Result:
					goto handle_Result

				case ffj_t_MandrillWebhookSpfno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Detail:

	/* handler: uj.Detail type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Detail = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Result:

	/* handler: uj.Result type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Result = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
