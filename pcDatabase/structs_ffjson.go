// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: pcDatabase/structs.go
// DO NOT EDIT!

package pcDatabase

import (
	"bytes"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *ADMResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ADMResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"access_token":`)
	fflib.WriteJsonString(buf, string(mj.AccessToken))
	buf.WriteString(`,"expires_in":`)
	fflib.FormatBits2(buf, uint64(mj.Expires), 10, mj.Expires < 0)
	buf.WriteString(`,"token_type":`)
	fflib.WriteJsonString(buf, string(mj.TokenType))
	buf.WriteString(`,"scope":`)
	fflib.WriteJsonString(buf, string(mj.Scope))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ADMResponsebase = iota
	ffj_t_ADMResponseno_such_key

	ffj_t_ADMResponse_AccessToken

	ffj_t_ADMResponse_Expires

	ffj_t_ADMResponse_TokenType

	ffj_t_ADMResponse_Scope
)

var ffj_key_ADMResponse_AccessToken = []byte("access_token")

var ffj_key_ADMResponse_Expires = []byte("expires_in")

var ffj_key_ADMResponse_TokenType = []byte("token_type")

var ffj_key_ADMResponse_Scope = []byte("scope")

func (uj *ADMResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ADMResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ADMResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ADMResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ADMResponse_AccessToken, kn) {
						currentKey = ffj_t_ADMResponse_AccessToken
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_ADMResponse_Expires, kn) {
						currentKey = ffj_t_ADMResponse_Expires
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ADMResponse_Scope, kn) {
						currentKey = ffj_t_ADMResponse_Scope
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ADMResponse_TokenType, kn) {
						currentKey = ffj_t_ADMResponse_TokenType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ADMResponse_Scope, kn) {
					currentKey = ffj_t_ADMResponse_Scope
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ADMResponse_TokenType, kn) {
					currentKey = ffj_t_ADMResponse_TokenType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ADMResponse_Expires, kn) {
					currentKey = ffj_t_ADMResponse_Expires
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ADMResponse_AccessToken, kn) {
					currentKey = ffj_t_ADMResponse_AccessToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ADMResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ADMResponse_AccessToken:
					goto handle_AccessToken

				case ffj_t_ADMResponse_Expires:
					goto handle_Expires

				case ffj_t_ADMResponse_TokenType:
					goto handle_TokenType

				case ffj_t_ADMResponse_Scope:
					goto handle_Scope

				case ffj_t_ADMResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AccessToken:

	/* handler: uj.AccessToken type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AccessToken = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Expires:

	/* handler: uj.Expires type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Expires = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TokenType:

	/* handler: uj.TokenType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.TokenType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Scope:

	/* handler: uj.Scope type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Scope = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *AutoreplyList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AutoreplyList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"Message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AutoreplyListbase = iota
	ffj_t_AutoreplyListno_such_key

	ffj_t_AutoreplyList_Username

	ffj_t_AutoreplyList_Message
)

var ffj_key_AutoreplyList_Username = []byte("Username")

var ffj_key_AutoreplyList_Message = []byte("Message")

func (uj *AutoreplyList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AutoreplyList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AutoreplyListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AutoreplyListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'M':

					if bytes.Equal(ffj_key_AutoreplyList_Message, kn) {
						currentKey = ffj_t_AutoreplyList_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_AutoreplyList_Username, kn) {
						currentKey = ffj_t_AutoreplyList_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_AutoreplyList_Message, kn) {
					currentKey = ffj_t_AutoreplyList_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AutoreplyList_Username, kn) {
					currentKey = ffj_t_AutoreplyList_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AutoreplyListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AutoreplyList_Username:
					goto handle_Username

				case ffj_t_AutoreplyList_Message:
					goto handle_Message

				case ffj_t_AutoreplyListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CIDCommandStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CIDCommandStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	buf.WriteString(`"CID":`)
	fflib.WriteJsonString(buf, string(mj.CID))
	buf.WriteString(`,"Name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"M_time":`)
	fflib.WriteJsonString(buf, string(mj.M_time))
	buf.WriteByte(',')
	if len(mj.Username) != 0 {
		buf.WriteString(`"Username":`)
		fflib.WriteJsonString(buf, string(mj.Username))
		buf.WriteByte(',')
	}
	buf.WriteString(`"Members":`)
	if mj.Members != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Members {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Messages) != 0 {
		buf.WriteString(`"Messages":`)
		if mj.Messages != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Messages {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CIDCommandStructbase = iota
	ffj_t_CIDCommandStructno_such_key

	ffj_t_CIDCommandStruct_Cmd

	ffj_t_CIDCommandStruct_CID

	ffj_t_CIDCommandStruct_Name

	ffj_t_CIDCommandStruct_M_time

	ffj_t_CIDCommandStruct_Username

	ffj_t_CIDCommandStruct_Members

	ffj_t_CIDCommandStruct_Messages
)

var ffj_key_CIDCommandStruct_Cmd = []byte("cmd")

var ffj_key_CIDCommandStruct_CID = []byte("CID")

var ffj_key_CIDCommandStruct_Name = []byte("Name")

var ffj_key_CIDCommandStruct_M_time = []byte("M_time")

var ffj_key_CIDCommandStruct_Username = []byte("Username")

var ffj_key_CIDCommandStruct_Members = []byte("Members")

var ffj_key_CIDCommandStruct_Messages = []byte("Messages")

func (uj *CIDCommandStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CIDCommandStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CIDCommandStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CIDCommandStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_CIDCommandStruct_CID, kn) {
						currentKey = ffj_t_CIDCommandStruct_CID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_CIDCommandStruct_M_time, kn) {
						currentKey = ffj_t_CIDCommandStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CIDCommandStruct_Members, kn) {
						currentKey = ffj_t_CIDCommandStruct_Members
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CIDCommandStruct_Messages, kn) {
						currentKey = ffj_t_CIDCommandStruct_Messages
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffj_key_CIDCommandStruct_Name, kn) {
						currentKey = ffj_t_CIDCommandStruct_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_CIDCommandStruct_Username, kn) {
						currentKey = ffj_t_CIDCommandStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_CIDCommandStruct_Cmd, kn) {
						currentKey = ffj_t_CIDCommandStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CIDCommandStruct_Messages, kn) {
					currentKey = ffj_t_CIDCommandStruct_Messages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CIDCommandStruct_Members, kn) {
					currentKey = ffj_t_CIDCommandStruct_Members
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CIDCommandStruct_Username, kn) {
					currentKey = ffj_t_CIDCommandStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CIDCommandStruct_M_time, kn) {
					currentKey = ffj_t_CIDCommandStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CIDCommandStruct_Name, kn) {
					currentKey = ffj_t_CIDCommandStruct_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CIDCommandStruct_CID, kn) {
					currentKey = ffj_t_CIDCommandStruct_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CIDCommandStruct_Cmd, kn) {
					currentKey = ffj_t_CIDCommandStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CIDCommandStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CIDCommandStruct_Cmd:
					goto handle_Cmd

				case ffj_t_CIDCommandStruct_CID:
					goto handle_CID

				case ffj_t_CIDCommandStruct_Name:
					goto handle_Name

				case ffj_t_CIDCommandStruct_M_time:
					goto handle_M_time

				case ffj_t_CIDCommandStruct_Username:
					goto handle_Username

				case ffj_t_CIDCommandStruct_Members:
					goto handle_Members

				case ffj_t_CIDCommandStruct_Messages:
					goto handle_Messages

				case ffj_t_CIDCommandStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.M_time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Members:

	/* handler: uj.Members type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Members = nil
		} else {

			uj.Members = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Members = append(uj.Members, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Messages:

	/* handler: uj.Messages type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Messages = nil
		} else {

			uj.Messages = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Messages = append(uj.Messages, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ChangeAccountStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ChangeAccountStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"phone":`)
	fflib.WriteJsonString(buf, string(mj.Phone))
	buf.WriteString(`,"email":`)
	fflib.WriteJsonString(buf, string(mj.Email))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ChangeAccountStructbase = iota
	ffj_t_ChangeAccountStructno_such_key

	ffj_t_ChangeAccountStruct_Cmd

	ffj_t_ChangeAccountStruct_Username

	ffj_t_ChangeAccountStruct_Phone

	ffj_t_ChangeAccountStruct_Email
)

var ffj_key_ChangeAccountStruct_Cmd = []byte("cmd")

var ffj_key_ChangeAccountStruct_Username = []byte("username")

var ffj_key_ChangeAccountStruct_Phone = []byte("phone")

var ffj_key_ChangeAccountStruct_Email = []byte("email")

func (uj *ChangeAccountStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ChangeAccountStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ChangeAccountStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ChangeAccountStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ChangeAccountStruct_Cmd, kn) {
						currentKey = ffj_t_ChangeAccountStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_ChangeAccountStruct_Email, kn) {
						currentKey = ffj_t_ChangeAccountStruct_Email
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ChangeAccountStruct_Phone, kn) {
						currentKey = ffj_t_ChangeAccountStruct_Phone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ChangeAccountStruct_Username, kn) {
						currentKey = ffj_t_ChangeAccountStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChangeAccountStruct_Email, kn) {
					currentKey = ffj_t_ChangeAccountStruct_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChangeAccountStruct_Phone, kn) {
					currentKey = ffj_t_ChangeAccountStruct_Phone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ChangeAccountStruct_Username, kn) {
					currentKey = ffj_t_ChangeAccountStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChangeAccountStruct_Cmd, kn) {
					currentKey = ffj_t_ChangeAccountStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ChangeAccountStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ChangeAccountStruct_Cmd:
					goto handle_Cmd

				case ffj_t_ChangeAccountStruct_Username:
					goto handle_Username

				case ffj_t_ChangeAccountStruct_Phone:
					goto handle_Phone

				case ffj_t_ChangeAccountStruct_Email:
					goto handle_Email

				case ffj_t_ChangeAccountStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phone:

	/* handler: uj.Phone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Phone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ChangeDeviceStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ChangeDeviceStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"device":`)
	fflib.WriteJsonString(buf, string(mj.Device))
	buf.WriteString(`,"old_device":`)
	fflib.WriteJsonString(buf, string(mj.OldDevice))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ChangeDeviceStructbase = iota
	ffj_t_ChangeDeviceStructno_such_key

	ffj_t_ChangeDeviceStruct_Cmd

	ffj_t_ChangeDeviceStruct_Username

	ffj_t_ChangeDeviceStruct_Device

	ffj_t_ChangeDeviceStruct_OldDevice
)

var ffj_key_ChangeDeviceStruct_Cmd = []byte("cmd")

var ffj_key_ChangeDeviceStruct_Username = []byte("username")

var ffj_key_ChangeDeviceStruct_Device = []byte("device")

var ffj_key_ChangeDeviceStruct_OldDevice = []byte("old_device")

func (uj *ChangeDeviceStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ChangeDeviceStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ChangeDeviceStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ChangeDeviceStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ChangeDeviceStruct_Cmd, kn) {
						currentKey = ffj_t_ChangeDeviceStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ChangeDeviceStruct_Device, kn) {
						currentKey = ffj_t_ChangeDeviceStruct_Device
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_ChangeDeviceStruct_OldDevice, kn) {
						currentKey = ffj_t_ChangeDeviceStruct_OldDevice
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ChangeDeviceStruct_Username, kn) {
						currentKey = ffj_t_ChangeDeviceStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ChangeDeviceStruct_OldDevice, kn) {
					currentKey = ffj_t_ChangeDeviceStruct_OldDevice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChangeDeviceStruct_Device, kn) {
					currentKey = ffj_t_ChangeDeviceStruct_Device
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ChangeDeviceStruct_Username, kn) {
					currentKey = ffj_t_ChangeDeviceStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChangeDeviceStruct_Cmd, kn) {
					currentKey = ffj_t_ChangeDeviceStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ChangeDeviceStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ChangeDeviceStruct_Cmd:
					goto handle_Cmd

				case ffj_t_ChangeDeviceStruct_Username:
					goto handle_Username

				case ffj_t_ChangeDeviceStruct_Device:
					goto handle_Device

				case ffj_t_ChangeDeviceStruct_OldDevice:
					goto handle_OldDevice

				case ffj_t_ChangeDeviceStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Device:

	/* handler: uj.Device type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Device = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OldDevice:

	/* handler: uj.OldDevice type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OldDevice = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ChangeUserPasswordStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ChangeUserPasswordStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"OldPassword":`)
	fflib.WriteJsonString(buf, string(mj.OldPassword))
	buf.WriteString(`,"NewPassword":`)
	fflib.WriteJsonString(buf, string(mj.NewPassword))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ChangeUserPasswordStructbase = iota
	ffj_t_ChangeUserPasswordStructno_such_key

	ffj_t_ChangeUserPasswordStruct_Cmd

	ffj_t_ChangeUserPasswordStruct_Username

	ffj_t_ChangeUserPasswordStruct_OldPassword

	ffj_t_ChangeUserPasswordStruct_NewPassword
)

var ffj_key_ChangeUserPasswordStruct_Cmd = []byte("cmd")

var ffj_key_ChangeUserPasswordStruct_Username = []byte("Username")

var ffj_key_ChangeUserPasswordStruct_OldPassword = []byte("OldPassword")

var ffj_key_ChangeUserPasswordStruct_NewPassword = []byte("NewPassword")

func (uj *ChangeUserPasswordStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ChangeUserPasswordStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ChangeUserPasswordStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ChangeUserPasswordStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'N':

					if bytes.Equal(ffj_key_ChangeUserPasswordStruct_NewPassword, kn) {
						currentKey = ffj_t_ChangeUserPasswordStruct_NewPassword
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffj_key_ChangeUserPasswordStruct_OldPassword, kn) {
						currentKey = ffj_t_ChangeUserPasswordStruct_OldPassword
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_ChangeUserPasswordStruct_Username, kn) {
						currentKey = ffj_t_ChangeUserPasswordStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_ChangeUserPasswordStruct_Cmd, kn) {
						currentKey = ffj_t_ChangeUserPasswordStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ChangeUserPasswordStruct_NewPassword, kn) {
					currentKey = ffj_t_ChangeUserPasswordStruct_NewPassword
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ChangeUserPasswordStruct_OldPassword, kn) {
					currentKey = ffj_t_ChangeUserPasswordStruct_OldPassword
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ChangeUserPasswordStruct_Username, kn) {
					currentKey = ffj_t_ChangeUserPasswordStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChangeUserPasswordStruct_Cmd, kn) {
					currentKey = ffj_t_ChangeUserPasswordStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ChangeUserPasswordStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ChangeUserPasswordStruct_Cmd:
					goto handle_Cmd

				case ffj_t_ChangeUserPasswordStruct_Username:
					goto handle_Username

				case ffj_t_ChangeUserPasswordStruct_OldPassword:
					goto handle_OldPassword

				case ffj_t_ChangeUserPasswordStruct_NewPassword:
					goto handle_NewPassword

				case ffj_t_ChangeUserPasswordStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OldPassword:

	/* handler: uj.OldPassword type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OldPassword = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewPassword:

	/* handler: uj.NewPassword type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.NewPassword = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CmdConvoAddFileStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CmdConvoAddFileStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	buf.WriteString(`"CID":`)
	fflib.WriteJsonString(buf, string(mj.CID))
	buf.WriteString(`,"f_username":`)
	fflib.WriteJsonString(buf, string(mj.FromUsername))
	buf.WriteString(`,"fileURL":`)
	fflib.WriteJsonString(buf, string(mj.FileURL))
	buf.WriteString(`,"m_time":`)
	fflib.WriteJsonString(buf, string(mj.M_time))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CmdConvoAddFileStructbase = iota
	ffj_t_CmdConvoAddFileStructno_such_key

	ffj_t_CmdConvoAddFileStruct_Cmd

	ffj_t_CmdConvoAddFileStruct_CID

	ffj_t_CmdConvoAddFileStruct_FromUsername

	ffj_t_CmdConvoAddFileStruct_FileURL

	ffj_t_CmdConvoAddFileStruct_M_time
)

var ffj_key_CmdConvoAddFileStruct_Cmd = []byte("cmd")

var ffj_key_CmdConvoAddFileStruct_CID = []byte("CID")

var ffj_key_CmdConvoAddFileStruct_FromUsername = []byte("f_username")

var ffj_key_CmdConvoAddFileStruct_FileURL = []byte("fileURL")

var ffj_key_CmdConvoAddFileStruct_M_time = []byte("m_time")

func (uj *CmdConvoAddFileStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CmdConvoAddFileStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CmdConvoAddFileStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CmdConvoAddFileStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_CmdConvoAddFileStruct_CID, kn) {
						currentKey = ffj_t_CmdConvoAddFileStruct_CID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_CmdConvoAddFileStruct_Cmd, kn) {
						currentKey = ffj_t_CmdConvoAddFileStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_CmdConvoAddFileStruct_FromUsername, kn) {
						currentKey = ffj_t_CmdConvoAddFileStruct_FromUsername
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CmdConvoAddFileStruct_FileURL, kn) {
						currentKey = ffj_t_CmdConvoAddFileStruct_FileURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_CmdConvoAddFileStruct_M_time, kn) {
						currentKey = ffj_t_CmdConvoAddFileStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_CmdConvoAddFileStruct_M_time, kn) {
					currentKey = ffj_t_CmdConvoAddFileStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoAddFileStruct_FileURL, kn) {
					currentKey = ffj_t_CmdConvoAddFileStruct_FileURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CmdConvoAddFileStruct_FromUsername, kn) {
					currentKey = ffj_t_CmdConvoAddFileStruct_FromUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoAddFileStruct_CID, kn) {
					currentKey = ffj_t_CmdConvoAddFileStruct_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoAddFileStruct_Cmd, kn) {
					currentKey = ffj_t_CmdConvoAddFileStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CmdConvoAddFileStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CmdConvoAddFileStruct_Cmd:
					goto handle_Cmd

				case ffj_t_CmdConvoAddFileStruct_CID:
					goto handle_CID

				case ffj_t_CmdConvoAddFileStruct_FromUsername:
					goto handle_FromUsername

				case ffj_t_CmdConvoAddFileStruct_FileURL:
					goto handle_FileURL

				case ffj_t_CmdConvoAddFileStruct_M_time:
					goto handle_M_time

				case ffj_t_CmdConvoAddFileStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FromUsername:

	/* handler: uj.FromUsername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromUsername = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileURL:

	/* handler: uj.FileURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.M_time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CmdConvoMember) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CmdConvoMember) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	buf.WriteString(`"CID":`)
	fflib.WriteJsonString(buf, string(mj.CID))
	buf.WriteString(`,"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"OldReadTime":`)
	fflib.WriteJsonString(buf, string(mj.OldReadTime))
	buf.WriteString(`,"NewReadTime":`)
	fflib.WriteJsonString(buf, string(mj.NewReadTime))
	if mj.Typing {
		buf.WriteString(`,"Typing":true`)
	} else {
		buf.WriteString(`,"Typing":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CmdConvoMemberbase = iota
	ffj_t_CmdConvoMemberno_such_key

	ffj_t_CmdConvoMember_Cmd

	ffj_t_CmdConvoMember_CID

	ffj_t_CmdConvoMember_Username

	ffj_t_CmdConvoMember_OldReadTime

	ffj_t_CmdConvoMember_NewReadTime

	ffj_t_CmdConvoMember_Typing
)

var ffj_key_CmdConvoMember_Cmd = []byte("cmd")

var ffj_key_CmdConvoMember_CID = []byte("CID")

var ffj_key_CmdConvoMember_Username = []byte("Username")

var ffj_key_CmdConvoMember_OldReadTime = []byte("OldReadTime")

var ffj_key_CmdConvoMember_NewReadTime = []byte("NewReadTime")

var ffj_key_CmdConvoMember_Typing = []byte("Typing")

func (uj *CmdConvoMember) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CmdConvoMember) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CmdConvoMemberbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CmdConvoMemberno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_CmdConvoMember_CID, kn) {
						currentKey = ffj_t_CmdConvoMember_CID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffj_key_CmdConvoMember_NewReadTime, kn) {
						currentKey = ffj_t_CmdConvoMember_NewReadTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffj_key_CmdConvoMember_OldReadTime, kn) {
						currentKey = ffj_t_CmdConvoMember_OldReadTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_CmdConvoMember_Typing, kn) {
						currentKey = ffj_t_CmdConvoMember_Typing
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_CmdConvoMember_Username, kn) {
						currentKey = ffj_t_CmdConvoMember_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_CmdConvoMember_Cmd, kn) {
						currentKey = ffj_t_CmdConvoMember_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoMember_Typing, kn) {
					currentKey = ffj_t_CmdConvoMember_Typing
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoMember_NewReadTime, kn) {
					currentKey = ffj_t_CmdConvoMember_NewReadTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoMember_OldReadTime, kn) {
					currentKey = ffj_t_CmdConvoMember_OldReadTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CmdConvoMember_Username, kn) {
					currentKey = ffj_t_CmdConvoMember_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoMember_CID, kn) {
					currentKey = ffj_t_CmdConvoMember_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoMember_Cmd, kn) {
					currentKey = ffj_t_CmdConvoMember_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CmdConvoMemberno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CmdConvoMember_Cmd:
					goto handle_Cmd

				case ffj_t_CmdConvoMember_CID:
					goto handle_CID

				case ffj_t_CmdConvoMember_Username:
					goto handle_Username

				case ffj_t_CmdConvoMember_OldReadTime:
					goto handle_OldReadTime

				case ffj_t_CmdConvoMember_NewReadTime:
					goto handle_NewReadTime

				case ffj_t_CmdConvoMember_Typing:
					goto handle_Typing

				case ffj_t_CmdConvoMemberno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OldReadTime:

	/* handler: uj.OldReadTime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OldReadTime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewReadTime:

	/* handler: uj.NewReadTime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.NewReadTime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Typing:

	/* handler: uj.Typing type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Typing = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Typing = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CmdConvoMtimeCount) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CmdConvoMtimeCount) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	buf.WriteString(`"CID":`)
	fflib.WriteJsonString(buf, string(mj.CID))
	buf.WriteString(`,"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"M_time":`)
	fflib.WriteJsonString(buf, string(mj.Mtime))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CmdConvoMtimeCountbase = iota
	ffj_t_CmdConvoMtimeCountno_such_key

	ffj_t_CmdConvoMtimeCount_Cmd

	ffj_t_CmdConvoMtimeCount_CID

	ffj_t_CmdConvoMtimeCount_Username

	ffj_t_CmdConvoMtimeCount_Mtime
)

var ffj_key_CmdConvoMtimeCount_Cmd = []byte("cmd")

var ffj_key_CmdConvoMtimeCount_CID = []byte("CID")

var ffj_key_CmdConvoMtimeCount_Username = []byte("Username")

var ffj_key_CmdConvoMtimeCount_Mtime = []byte("M_time")

func (uj *CmdConvoMtimeCount) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CmdConvoMtimeCount) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CmdConvoMtimeCountbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CmdConvoMtimeCountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_CmdConvoMtimeCount_CID, kn) {
						currentKey = ffj_t_CmdConvoMtimeCount_CID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_CmdConvoMtimeCount_Mtime, kn) {
						currentKey = ffj_t_CmdConvoMtimeCount_Mtime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_CmdConvoMtimeCount_Username, kn) {
						currentKey = ffj_t_CmdConvoMtimeCount_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_CmdConvoMtimeCount_Cmd, kn) {
						currentKey = ffj_t_CmdConvoMtimeCount_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_CmdConvoMtimeCount_Mtime, kn) {
					currentKey = ffj_t_CmdConvoMtimeCount_Mtime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CmdConvoMtimeCount_Username, kn) {
					currentKey = ffj_t_CmdConvoMtimeCount_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoMtimeCount_CID, kn) {
					currentKey = ffj_t_CmdConvoMtimeCount_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoMtimeCount_Cmd, kn) {
					currentKey = ffj_t_CmdConvoMtimeCount_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CmdConvoMtimeCountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CmdConvoMtimeCount_Cmd:
					goto handle_Cmd

				case ffj_t_CmdConvoMtimeCount_CID:
					goto handle_CID

				case ffj_t_CmdConvoMtimeCount_Username:
					goto handle_Username

				case ffj_t_CmdConvoMtimeCount_Mtime:
					goto handle_Mtime

				case ffj_t_CmdConvoMtimeCountno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mtime:

	/* handler: uj.Mtime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Mtime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CmdConvoUnreadCount) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CmdConvoUnreadCount) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	buf.WriteString(`"CID":`)
	fflib.WriteJsonString(buf, string(mj.CID))
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"unread_count":`)
	fflib.FormatBits2(buf, uint64(mj.UnreadCount), 10, mj.UnreadCount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CmdConvoUnreadCountbase = iota
	ffj_t_CmdConvoUnreadCountno_such_key

	ffj_t_CmdConvoUnreadCount_Cmd

	ffj_t_CmdConvoUnreadCount_CID

	ffj_t_CmdConvoUnreadCount_Username

	ffj_t_CmdConvoUnreadCount_UnreadCount
)

var ffj_key_CmdConvoUnreadCount_Cmd = []byte("cmd")

var ffj_key_CmdConvoUnreadCount_CID = []byte("CID")

var ffj_key_CmdConvoUnreadCount_Username = []byte("username")

var ffj_key_CmdConvoUnreadCount_UnreadCount = []byte("unread_count")

func (uj *CmdConvoUnreadCount) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CmdConvoUnreadCount) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CmdConvoUnreadCountbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CmdConvoUnreadCountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_CmdConvoUnreadCount_CID, kn) {
						currentKey = ffj_t_CmdConvoUnreadCount_CID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_CmdConvoUnreadCount_Cmd, kn) {
						currentKey = ffj_t_CmdConvoUnreadCount_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_CmdConvoUnreadCount_Username, kn) {
						currentKey = ffj_t_CmdConvoUnreadCount_Username
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CmdConvoUnreadCount_UnreadCount, kn) {
						currentKey = ffj_t_CmdConvoUnreadCount_UnreadCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_CmdConvoUnreadCount_UnreadCount, kn) {
					currentKey = ffj_t_CmdConvoUnreadCount_UnreadCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CmdConvoUnreadCount_Username, kn) {
					currentKey = ffj_t_CmdConvoUnreadCount_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoUnreadCount_CID, kn) {
					currentKey = ffj_t_CmdConvoUnreadCount_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CmdConvoUnreadCount_Cmd, kn) {
					currentKey = ffj_t_CmdConvoUnreadCount_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CmdConvoUnreadCountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CmdConvoUnreadCount_Cmd:
					goto handle_Cmd

				case ffj_t_CmdConvoUnreadCount_CID:
					goto handle_CID

				case ffj_t_CmdConvoUnreadCount_Username:
					goto handle_Username

				case ffj_t_CmdConvoUnreadCount_UnreadCount:
					goto handle_UnreadCount

				case ffj_t_CmdConvoUnreadCountno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UnreadCount:

	/* handler: uj.UnreadCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.UnreadCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CommonCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CommonCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"password":`)
	fflib.WriteJsonString(buf, string(mj.Password))
	buf.WriteString(`,"token":`)
	fflib.WriteJsonString(buf, string(mj.Token))
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CommonCmdStructbase = iota
	ffj_t_CommonCmdStructno_such_key

	ffj_t_CommonCmdStruct_Cmd

	ffj_t_CommonCmdStruct_Password

	ffj_t_CommonCmdStruct_Token

	ffj_t_CommonCmdStruct_Username
)

var ffj_key_CommonCmdStruct_Cmd = []byte("cmd")

var ffj_key_CommonCmdStruct_Password = []byte("password")

var ffj_key_CommonCmdStruct_Token = []byte("token")

var ffj_key_CommonCmdStruct_Username = []byte("username")

func (uj *CommonCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CommonCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CommonCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CommonCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_CommonCmdStruct_Cmd, kn) {
						currentKey = ffj_t_CommonCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_CommonCmdStruct_Password, kn) {
						currentKey = ffj_t_CommonCmdStruct_Password
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_CommonCmdStruct_Token, kn) {
						currentKey = ffj_t_CommonCmdStruct_Token
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_CommonCmdStruct_Username, kn) {
						currentKey = ffj_t_CommonCmdStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CommonCmdStruct_Username, kn) {
					currentKey = ffj_t_CommonCmdStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CommonCmdStruct_Token, kn) {
					currentKey = ffj_t_CommonCmdStruct_Token
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CommonCmdStruct_Password, kn) {
					currentKey = ffj_t_CommonCmdStruct_Password
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CommonCmdStruct_Cmd, kn) {
					currentKey = ffj_t_CommonCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CommonCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CommonCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_CommonCmdStruct_Password:
					goto handle_Password

				case ffj_t_CommonCmdStruct_Token:
					goto handle_Token

				case ffj_t_CommonCmdStruct_Username:
					goto handle_Username

				case ffj_t_CommonCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Password:

	/* handler: uj.Password type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Password = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Token:

	/* handler: uj.Token type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Token = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ConvoDataStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ConvoDataStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	if len(mj.CID) != 0 {
		buf.WriteString(`"CID":`)
		fflib.WriteJsonString(buf, string(mj.CID))
		buf.WriteByte(',')
	}
	if len(mj.Name) != 0 {
		buf.WriteString(`"Name":`)
		fflib.WriteJsonString(buf, string(mj.Name))
		buf.WriteByte(',')
	}
	if len(mj.M_time) != 0 {
		buf.WriteString(`"M_time":`)
		fflib.WriteJsonString(buf, string(mj.M_time))
		buf.WriteByte(',')
	}
	if len(mj.Members) != 0 {
		buf.WriteString(`"Members":`)
		if mj.Members != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Members {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Files) != 0 {
		buf.WriteString(`"Files":`)
		if mj.Files != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Files {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Messages) != 0 {
		buf.WriteString(`"Messages":`)
		if mj.Messages != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Messages {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ConvoDataStructbase = iota
	ffj_t_ConvoDataStructno_such_key

	ffj_t_ConvoDataStruct_Cmd

	ffj_t_ConvoDataStruct_CID

	ffj_t_ConvoDataStruct_Name

	ffj_t_ConvoDataStruct_M_time

	ffj_t_ConvoDataStruct_Members

	ffj_t_ConvoDataStruct_Files

	ffj_t_ConvoDataStruct_Messages
)

var ffj_key_ConvoDataStruct_Cmd = []byte("cmd")

var ffj_key_ConvoDataStruct_CID = []byte("CID")

var ffj_key_ConvoDataStruct_Name = []byte("Name")

var ffj_key_ConvoDataStruct_M_time = []byte("M_time")

var ffj_key_ConvoDataStruct_Members = []byte("Members")

var ffj_key_ConvoDataStruct_Files = []byte("Files")

var ffj_key_ConvoDataStruct_Messages = []byte("Messages")

func (uj *ConvoDataStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ConvoDataStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ConvoDataStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ConvoDataStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_ConvoDataStruct_CID, kn) {
						currentKey = ffj_t_ConvoDataStruct_CID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_ConvoDataStruct_Files, kn) {
						currentKey = ffj_t_ConvoDataStruct_Files
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_ConvoDataStruct_M_time, kn) {
						currentKey = ffj_t_ConvoDataStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ConvoDataStruct_Members, kn) {
						currentKey = ffj_t_ConvoDataStruct_Members
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ConvoDataStruct_Messages, kn) {
						currentKey = ffj_t_ConvoDataStruct_Messages
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffj_key_ConvoDataStruct_Name, kn) {
						currentKey = ffj_t_ConvoDataStruct_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_ConvoDataStruct_Cmd, kn) {
						currentKey = ffj_t_ConvoDataStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ConvoDataStruct_Messages, kn) {
					currentKey = ffj_t_ConvoDataStruct_Messages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ConvoDataStruct_Files, kn) {
					currentKey = ffj_t_ConvoDataStruct_Files
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ConvoDataStruct_Members, kn) {
					currentKey = ffj_t_ConvoDataStruct_Members
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ConvoDataStruct_M_time, kn) {
					currentKey = ffj_t_ConvoDataStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ConvoDataStruct_Name, kn) {
					currentKey = ffj_t_ConvoDataStruct_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ConvoDataStruct_CID, kn) {
					currentKey = ffj_t_ConvoDataStruct_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ConvoDataStruct_Cmd, kn) {
					currentKey = ffj_t_ConvoDataStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ConvoDataStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ConvoDataStruct_Cmd:
					goto handle_Cmd

				case ffj_t_ConvoDataStruct_CID:
					goto handle_CID

				case ffj_t_ConvoDataStruct_Name:
					goto handle_Name

				case ffj_t_ConvoDataStruct_M_time:
					goto handle_M_time

				case ffj_t_ConvoDataStruct_Members:
					goto handle_Members

				case ffj_t_ConvoDataStruct_Files:
					goto handle_Files

				case ffj_t_ConvoDataStruct_Messages:
					goto handle_Messages

				case ffj_t_ConvoDataStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.M_time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Members:

	/* handler: uj.Members type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Members = nil
		} else {

			uj.Members = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Members = append(uj.Members, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Files:

	/* handler: uj.Files type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Files = nil
		} else {

			uj.Files = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Files = append(uj.Files, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Messages:

	/* handler: uj.Messages type=[]pcDatabase.ConvoRowStruct kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Messages = nil
		} else {

			uj.Messages = make([]ConvoRowStruct, 0)

			wantVal := true

			for {

				var v ConvoRowStruct

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=pcDatabase.ConvoRowStruct kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Messages = append(uj.Messages, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ConvoFileListStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ConvoFileListStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"f_username":`)
	fflib.WriteJsonString(buf, string(mj.FromUsername))
	buf.WriteString(`,"fileURL":`)
	fflib.WriteJsonString(buf, string(mj.FileURL))
	buf.WriteString(`,"m_time":`)
	fflib.WriteJsonString(buf, string(mj.M_time))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ConvoFileListStructbase = iota
	ffj_t_ConvoFileListStructno_such_key

	ffj_t_ConvoFileListStruct_FromUsername

	ffj_t_ConvoFileListStruct_FileURL

	ffj_t_ConvoFileListStruct_M_time
)

var ffj_key_ConvoFileListStruct_FromUsername = []byte("f_username")

var ffj_key_ConvoFileListStruct_FileURL = []byte("fileURL")

var ffj_key_ConvoFileListStruct_M_time = []byte("m_time")

func (uj *ConvoFileListStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ConvoFileListStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ConvoFileListStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ConvoFileListStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_ConvoFileListStruct_FromUsername, kn) {
						currentKey = ffj_t_ConvoFileListStruct_FromUsername
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ConvoFileListStruct_FileURL, kn) {
						currentKey = ffj_t_ConvoFileListStruct_FileURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ConvoFileListStruct_M_time, kn) {
						currentKey = ffj_t_ConvoFileListStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_ConvoFileListStruct_M_time, kn) {
					currentKey = ffj_t_ConvoFileListStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ConvoFileListStruct_FileURL, kn) {
					currentKey = ffj_t_ConvoFileListStruct_FileURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ConvoFileListStruct_FromUsername, kn) {
					currentKey = ffj_t_ConvoFileListStruct_FromUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ConvoFileListStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ConvoFileListStruct_FromUsername:
					goto handle_FromUsername

				case ffj_t_ConvoFileListStruct_FileURL:
					goto handle_FileURL

				case ffj_t_ConvoFileListStruct_M_time:
					goto handle_M_time

				case ffj_t_ConvoFileListStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FromUsername:

	/* handler: uj.FromUsername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromUsername = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileURL:

	/* handler: uj.FileURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.M_time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ConvoMember) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ConvoMember) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"read_time":`)
	fflib.WriteJsonString(buf, string(mj.ReadTime))
	if mj.Typing {
		buf.WriteString(`,"typing":true`)
	} else {
		buf.WriteString(`,"typing":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ConvoMemberbase = iota
	ffj_t_ConvoMemberno_such_key

	ffj_t_ConvoMember_Username

	ffj_t_ConvoMember_ReadTime

	ffj_t_ConvoMember_Typing
)

var ffj_key_ConvoMember_Username = []byte("username")

var ffj_key_ConvoMember_ReadTime = []byte("read_time")

var ffj_key_ConvoMember_Typing = []byte("typing")

func (uj *ConvoMember) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ConvoMember) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ConvoMemberbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ConvoMemberno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_ConvoMember_ReadTime, kn) {
						currentKey = ffj_t_ConvoMember_ReadTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ConvoMember_Typing, kn) {
						currentKey = ffj_t_ConvoMember_Typing
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ConvoMember_Username, kn) {
						currentKey = ffj_t_ConvoMember_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ConvoMember_Typing, kn) {
					currentKey = ffj_t_ConvoMember_Typing
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ConvoMember_ReadTime, kn) {
					currentKey = ffj_t_ConvoMember_ReadTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ConvoMember_Username, kn) {
					currentKey = ffj_t_ConvoMember_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ConvoMemberno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ConvoMember_Username:
					goto handle_Username

				case ffj_t_ConvoMember_ReadTime:
					goto handle_ReadTime

				case ffj_t_ConvoMember_Typing:
					goto handle_Typing

				case ffj_t_ConvoMemberno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadTime:

	/* handler: uj.ReadTime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ReadTime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Typing:

	/* handler: uj.Typing type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Typing = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Typing = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ConvoRowStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ConvoRowStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"f_username":`)
	fflib.WriteJsonString(buf, string(mj.F_username))
	buf.WriteString(`,"m_time":`)

	{

		obj, err = mj.M_time.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"content":`)
	fflib.WriteJsonString(buf, string(mj.Content))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ConvoRowStructbase = iota
	ffj_t_ConvoRowStructno_such_key

	ffj_t_ConvoRowStruct_F_username

	ffj_t_ConvoRowStruct_M_time

	ffj_t_ConvoRowStruct_Content
)

var ffj_key_ConvoRowStruct_F_username = []byte("f_username")

var ffj_key_ConvoRowStruct_M_time = []byte("m_time")

var ffj_key_ConvoRowStruct_Content = []byte("content")

func (uj *ConvoRowStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ConvoRowStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ConvoRowStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ConvoRowStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ConvoRowStruct_Content, kn) {
						currentKey = ffj_t_ConvoRowStruct_Content
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_ConvoRowStruct_F_username, kn) {
						currentKey = ffj_t_ConvoRowStruct_F_username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ConvoRowStruct_M_time, kn) {
						currentKey = ffj_t_ConvoRowStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ConvoRowStruct_Content, kn) {
					currentKey = ffj_t_ConvoRowStruct_Content
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ConvoRowStruct_M_time, kn) {
					currentKey = ffj_t_ConvoRowStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ConvoRowStruct_F_username, kn) {
					currentKey = ffj_t_ConvoRowStruct_F_username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ConvoRowStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ConvoRowStruct_F_username:
					goto handle_F_username

				case ffj_t_ConvoRowStruct_M_time:
					goto handle_M_time

				case ffj_t_ConvoRowStruct_Content:
					goto handle_Content

				case ffj_t_ConvoRowStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_F_username:

	/* handler: uj.F_username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.F_username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.M_time.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: uj.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CreateUserCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CreateUserCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"password":`)
	fflib.WriteJsonString(buf, string(mj.Password))
	buf.WriteString(`,"email":`)
	fflib.WriteJsonString(buf, string(mj.Email))
	buf.WriteString(`,"phone":`)
	fflib.WriteJsonString(buf, string(mj.Phone))
	buf.WriteString(`,"token":`)
	fflib.WriteJsonString(buf, string(mj.Token))
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"secQuests":`)
	fflib.WriteJsonString(buf, string(mj.SecQuests))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CreateUserCmdStructbase = iota
	ffj_t_CreateUserCmdStructno_such_key

	ffj_t_CreateUserCmdStruct_Cmd

	ffj_t_CreateUserCmdStruct_Password

	ffj_t_CreateUserCmdStruct_Email

	ffj_t_CreateUserCmdStruct_Phone

	ffj_t_CreateUserCmdStruct_Token

	ffj_t_CreateUserCmdStruct_Username

	ffj_t_CreateUserCmdStruct_SecQuests
)

var ffj_key_CreateUserCmdStruct_Cmd = []byte("cmd")

var ffj_key_CreateUserCmdStruct_Password = []byte("password")

var ffj_key_CreateUserCmdStruct_Email = []byte("email")

var ffj_key_CreateUserCmdStruct_Phone = []byte("phone")

var ffj_key_CreateUserCmdStruct_Token = []byte("token")

var ffj_key_CreateUserCmdStruct_Username = []byte("username")

var ffj_key_CreateUserCmdStruct_SecQuests = []byte("secQuests")

func (uj *CreateUserCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CreateUserCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CreateUserCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CreateUserCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_CreateUserCmdStruct_Cmd, kn) {
						currentKey = ffj_t_CreateUserCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_CreateUserCmdStruct_Email, kn) {
						currentKey = ffj_t_CreateUserCmdStruct_Email
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_CreateUserCmdStruct_Password, kn) {
						currentKey = ffj_t_CreateUserCmdStruct_Password
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CreateUserCmdStruct_Phone, kn) {
						currentKey = ffj_t_CreateUserCmdStruct_Phone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_CreateUserCmdStruct_SecQuests, kn) {
						currentKey = ffj_t_CreateUserCmdStruct_SecQuests
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_CreateUserCmdStruct_Token, kn) {
						currentKey = ffj_t_CreateUserCmdStruct_Token
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_CreateUserCmdStruct_Username, kn) {
						currentKey = ffj_t_CreateUserCmdStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CreateUserCmdStruct_SecQuests, kn) {
					currentKey = ffj_t_CreateUserCmdStruct_SecQuests
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CreateUserCmdStruct_Username, kn) {
					currentKey = ffj_t_CreateUserCmdStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CreateUserCmdStruct_Token, kn) {
					currentKey = ffj_t_CreateUserCmdStruct_Token
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CreateUserCmdStruct_Phone, kn) {
					currentKey = ffj_t_CreateUserCmdStruct_Phone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CreateUserCmdStruct_Email, kn) {
					currentKey = ffj_t_CreateUserCmdStruct_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CreateUserCmdStruct_Password, kn) {
					currentKey = ffj_t_CreateUserCmdStruct_Password
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CreateUserCmdStruct_Cmd, kn) {
					currentKey = ffj_t_CreateUserCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CreateUserCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CreateUserCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_CreateUserCmdStruct_Password:
					goto handle_Password

				case ffj_t_CreateUserCmdStruct_Email:
					goto handle_Email

				case ffj_t_CreateUserCmdStruct_Phone:
					goto handle_Phone

				case ffj_t_CreateUserCmdStruct_Token:
					goto handle_Token

				case ffj_t_CreateUserCmdStruct_Username:
					goto handle_Username

				case ffj_t_CreateUserCmdStruct_SecQuests:
					goto handle_SecQuests

				case ffj_t_CreateUserCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Password:

	/* handler: uj.Password type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Password = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phone:

	/* handler: uj.Phone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Phone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Token:

	/* handler: uj.Token type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Token = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SecQuests:

	/* handler: uj.SecQuests type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SecQuests = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EmailDataStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EmailDataStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	if len(mj.Emails) != 0 {
		buf.WriteString(`"Messages":`)
		if mj.Emails != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Emails {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EmailDataStructbase = iota
	ffj_t_EmailDataStructno_such_key

	ffj_t_EmailDataStruct_Cmd

	ffj_t_EmailDataStruct_Emails
)

var ffj_key_EmailDataStruct_Cmd = []byte("cmd")

var ffj_key_EmailDataStruct_Emails = []byte("Messages")

func (uj *EmailDataStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EmailDataStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EmailDataStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EmailDataStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'M':

					if bytes.Equal(ffj_key_EmailDataStruct_Emails, kn) {
						currentKey = ffj_t_EmailDataStruct_Emails
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_EmailDataStruct_Cmd, kn) {
						currentKey = ffj_t_EmailDataStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_EmailDataStruct_Emails, kn) {
					currentKey = ffj_t_EmailDataStruct_Emails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailDataStruct_Cmd, kn) {
					currentKey = ffj_t_EmailDataStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EmailDataStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EmailDataStruct_Cmd:
					goto handle_Cmd

				case ffj_t_EmailDataStruct_Emails:
					goto handle_Emails

				case ffj_t_EmailDataStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emails:

	/* handler: uj.Emails type=[]pcDatabase.EmailRowStruct kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Emails = nil
		} else {

			uj.Emails = make([]EmailRowStruct, 0)

			wantVal := true

			for {

				var v EmailRowStruct

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=pcDatabase.EmailRowStruct kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Emails = append(uj.Emails, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EmailRowStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EmailRowStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"from_email":`)
	fflib.WriteJsonString(buf, string(mj.FromEmail))
	buf.WriteString(`,"to_emails":`)
	fflib.WriteJsonString(buf, string(mj.ToEmails))
	buf.WriteString(`,"recv_email":`)
	fflib.WriteJsonString(buf, string(mj.RecvEmail))
	buf.WriteString(`,"subject":`)
	fflib.WriteJsonString(buf, string(mj.Subject))
	buf.WriteString(`,"content":`)
	fflib.WriteJsonString(buf, string(mj.Content))
	buf.WriteString(`,"attachments":`)
	fflib.WriteJsonString(buf, string(mj.Attachments))
	if mj.Starred {
		buf.WriteString(`,"starred":true`)
	} else {
		buf.WriteString(`,"starred":false`)
	}
	if mj.Unread {
		buf.WriteString(`,"unread":true`)
	} else {
		buf.WriteString(`,"unread":false`)
	}
	if mj.Spam {
		buf.WriteString(`,"spam":true`)
	} else {
		buf.WriteString(`,"spam":false`)
	}
	if mj.Draft {
		buf.WriteString(`,"draft":true`)
	} else {
		buf.WriteString(`,"draft":false`)
	}
	if mj.Deleted {
		buf.WriteString(`,"deleted":true`)
	} else {
		buf.WriteString(`,"deleted":false`)
	}
	buf.WriteString(`,"recv_time":`)

	{

		obj, err = mj.RecvTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"m_time":`)

	{

		obj, err = mj.M_time.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EmailRowStructbase = iota
	ffj_t_EmailRowStructno_such_key

	ffj_t_EmailRowStruct_FromEmail

	ffj_t_EmailRowStruct_ToEmails

	ffj_t_EmailRowStruct_RecvEmail

	ffj_t_EmailRowStruct_Subject

	ffj_t_EmailRowStruct_Content

	ffj_t_EmailRowStruct_Attachments

	ffj_t_EmailRowStruct_Starred

	ffj_t_EmailRowStruct_Unread

	ffj_t_EmailRowStruct_Spam

	ffj_t_EmailRowStruct_Draft

	ffj_t_EmailRowStruct_Deleted

	ffj_t_EmailRowStruct_RecvTime

	ffj_t_EmailRowStruct_M_time
)

var ffj_key_EmailRowStruct_FromEmail = []byte("from_email")

var ffj_key_EmailRowStruct_ToEmails = []byte("to_emails")

var ffj_key_EmailRowStruct_RecvEmail = []byte("recv_email")

var ffj_key_EmailRowStruct_Subject = []byte("subject")

var ffj_key_EmailRowStruct_Content = []byte("content")

var ffj_key_EmailRowStruct_Attachments = []byte("attachments")

var ffj_key_EmailRowStruct_Starred = []byte("starred")

var ffj_key_EmailRowStruct_Unread = []byte("unread")

var ffj_key_EmailRowStruct_Spam = []byte("spam")

var ffj_key_EmailRowStruct_Draft = []byte("draft")

var ffj_key_EmailRowStruct_Deleted = []byte("deleted")

var ffj_key_EmailRowStruct_RecvTime = []byte("recv_time")

var ffj_key_EmailRowStruct_M_time = []byte("m_time")

func (uj *EmailRowStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EmailRowStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EmailRowStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EmailRowStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_EmailRowStruct_Attachments, kn) {
						currentKey = ffj_t_EmailRowStruct_Attachments
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_EmailRowStruct_Content, kn) {
						currentKey = ffj_t_EmailRowStruct_Content
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_EmailRowStruct_Draft, kn) {
						currentKey = ffj_t_EmailRowStruct_Draft
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_EmailRowStruct_Deleted, kn) {
						currentKey = ffj_t_EmailRowStruct_Deleted
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_EmailRowStruct_FromEmail, kn) {
						currentKey = ffj_t_EmailRowStruct_FromEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_EmailRowStruct_M_time, kn) {
						currentKey = ffj_t_EmailRowStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_EmailRowStruct_RecvEmail, kn) {
						currentKey = ffj_t_EmailRowStruct_RecvEmail
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_EmailRowStruct_RecvTime, kn) {
						currentKey = ffj_t_EmailRowStruct_RecvTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_EmailRowStruct_Subject, kn) {
						currentKey = ffj_t_EmailRowStruct_Subject
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_EmailRowStruct_Starred, kn) {
						currentKey = ffj_t_EmailRowStruct_Starred
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_EmailRowStruct_Spam, kn) {
						currentKey = ffj_t_EmailRowStruct_Spam
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_EmailRowStruct_ToEmails, kn) {
						currentKey = ffj_t_EmailRowStruct_ToEmails
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_EmailRowStruct_Unread, kn) {
						currentKey = ffj_t_EmailRowStruct_Unread
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_EmailRowStruct_M_time, kn) {
					currentKey = ffj_t_EmailRowStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_EmailRowStruct_RecvTime, kn) {
					currentKey = ffj_t_EmailRowStruct_RecvTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRowStruct_Deleted, kn) {
					currentKey = ffj_t_EmailRowStruct_Deleted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRowStruct_Draft, kn) {
					currentKey = ffj_t_EmailRowStruct_Draft
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EmailRowStruct_Spam, kn) {
					currentKey = ffj_t_EmailRowStruct_Spam
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRowStruct_Unread, kn) {
					currentKey = ffj_t_EmailRowStruct_Unread
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EmailRowStruct_Starred, kn) {
					currentKey = ffj_t_EmailRowStruct_Starred
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EmailRowStruct_Attachments, kn) {
					currentKey = ffj_t_EmailRowStruct_Attachments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRowStruct_Content, kn) {
					currentKey = ffj_t_EmailRowStruct_Content
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EmailRowStruct_Subject, kn) {
					currentKey = ffj_t_EmailRowStruct_Subject
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_EmailRowStruct_RecvEmail, kn) {
					currentKey = ffj_t_EmailRowStruct_RecvEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EmailRowStruct_ToEmails, kn) {
					currentKey = ffj_t_EmailRowStruct_ToEmails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_EmailRowStruct_FromEmail, kn) {
					currentKey = ffj_t_EmailRowStruct_FromEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EmailRowStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EmailRowStruct_FromEmail:
					goto handle_FromEmail

				case ffj_t_EmailRowStruct_ToEmails:
					goto handle_ToEmails

				case ffj_t_EmailRowStruct_RecvEmail:
					goto handle_RecvEmail

				case ffj_t_EmailRowStruct_Subject:
					goto handle_Subject

				case ffj_t_EmailRowStruct_Content:
					goto handle_Content

				case ffj_t_EmailRowStruct_Attachments:
					goto handle_Attachments

				case ffj_t_EmailRowStruct_Starred:
					goto handle_Starred

				case ffj_t_EmailRowStruct_Unread:
					goto handle_Unread

				case ffj_t_EmailRowStruct_Spam:
					goto handle_Spam

				case ffj_t_EmailRowStruct_Draft:
					goto handle_Draft

				case ffj_t_EmailRowStruct_Deleted:
					goto handle_Deleted

				case ffj_t_EmailRowStruct_RecvTime:
					goto handle_RecvTime

				case ffj_t_EmailRowStruct_M_time:
					goto handle_M_time

				case ffj_t_EmailRowStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FromEmail:

	/* handler: uj.FromEmail type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromEmail = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ToEmails:

	/* handler: uj.ToEmails type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ToEmails = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RecvEmail:

	/* handler: uj.RecvEmail type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.RecvEmail = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Subject:

	/* handler: uj.Subject type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Subject = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: uj.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attachments:

	/* handler: uj.Attachments type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Attachments = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Starred:

	/* handler: uj.Starred type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Starred = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Starred = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unread:

	/* handler: uj.Unread type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Unread = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Unread = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spam:

	/* handler: uj.Spam type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Spam = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Spam = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Draft:

	/* handler: uj.Draft type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Draft = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Draft = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deleted:

	/* handler: uj.Deleted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Deleted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Deleted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RecvTime:

	/* handler: uj.RecvTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.RecvTime.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.M_time.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *FoundUserStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FoundUserStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"ProfilePic":`)
	fflib.WriteJsonString(buf, string(mj.ProfilePic))
	buf.WriteString(`,"Email":`)
	fflib.WriteJsonString(buf, string(mj.Email))
	buf.WriteString(`,"Phone":`)
	fflib.WriteJsonString(buf, string(mj.Phone))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FoundUserStructbase = iota
	ffj_t_FoundUserStructno_such_key

	ffj_t_FoundUserStruct_Username

	ffj_t_FoundUserStruct_ProfilePic

	ffj_t_FoundUserStruct_Email

	ffj_t_FoundUserStruct_Phone
)

var ffj_key_FoundUserStruct_Username = []byte("Username")

var ffj_key_FoundUserStruct_ProfilePic = []byte("ProfilePic")

var ffj_key_FoundUserStruct_Email = []byte("Email")

var ffj_key_FoundUserStruct_Phone = []byte("Phone")

func (uj *FoundUserStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FoundUserStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FoundUserStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FoundUserStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'E':

					if bytes.Equal(ffj_key_FoundUserStruct_Email, kn) {
						currentKey = ffj_t_FoundUserStruct_Email
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_FoundUserStruct_ProfilePic, kn) {
						currentKey = ffj_t_FoundUserStruct_ProfilePic
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_FoundUserStruct_Phone, kn) {
						currentKey = ffj_t_FoundUserStruct_Phone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_FoundUserStruct_Username, kn) {
						currentKey = ffj_t_FoundUserStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_FoundUserStruct_Phone, kn) {
					currentKey = ffj_t_FoundUserStruct_Phone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FoundUserStruct_Email, kn) {
					currentKey = ffj_t_FoundUserStruct_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FoundUserStruct_ProfilePic, kn) {
					currentKey = ffj_t_FoundUserStruct_ProfilePic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_FoundUserStruct_Username, kn) {
					currentKey = ffj_t_FoundUserStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FoundUserStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FoundUserStruct_Username:
					goto handle_Username

				case ffj_t_FoundUserStruct_ProfilePic:
					goto handle_ProfilePic

				case ffj_t_FoundUserStruct_Email:
					goto handle_Email

				case ffj_t_FoundUserStruct_Phone:
					goto handle_Phone

				case ffj_t_FoundUserStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfilePic:

	/* handler: uj.ProfilePic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProfilePic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phone:

	/* handler: uj.Phone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Phone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *FriendCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *FriendCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"UID":`)
	fflib.WriteJsonString(buf, string(mj.UID))
	buf.WriteString(`,"friend_UID":`)
	fflib.WriteJsonString(buf, string(mj.FriendUID))
	buf.WriteString(`,"Message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_FriendCmdStructbase = iota
	ffj_t_FriendCmdStructno_such_key

	ffj_t_FriendCmdStruct_Cmd

	ffj_t_FriendCmdStruct_UID

	ffj_t_FriendCmdStruct_FriendUID

	ffj_t_FriendCmdStruct_Message
)

var ffj_key_FriendCmdStruct_Cmd = []byte("cmd")

var ffj_key_FriendCmdStruct_UID = []byte("UID")

var ffj_key_FriendCmdStruct_FriendUID = []byte("friend_UID")

var ffj_key_FriendCmdStruct_Message = []byte("Message")

func (uj *FriendCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *FriendCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_FriendCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_FriendCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'M':

					if bytes.Equal(ffj_key_FriendCmdStruct_Message, kn) {
						currentKey = ffj_t_FriendCmdStruct_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_FriendCmdStruct_UID, kn) {
						currentKey = ffj_t_FriendCmdStruct_UID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_FriendCmdStruct_Cmd, kn) {
						currentKey = ffj_t_FriendCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_FriendCmdStruct_FriendUID, kn) {
						currentKey = ffj_t_FriendCmdStruct_FriendUID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_FriendCmdStruct_Message, kn) {
					currentKey = ffj_t_FriendCmdStruct_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_FriendCmdStruct_FriendUID, kn) {
					currentKey = ffj_t_FriendCmdStruct_FriendUID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FriendCmdStruct_UID, kn) {
					currentKey = ffj_t_FriendCmdStruct_UID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_FriendCmdStruct_Cmd, kn) {
					currentKey = ffj_t_FriendCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_FriendCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_FriendCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_FriendCmdStruct_UID:
					goto handle_UID

				case ffj_t_FriendCmdStruct_FriendUID:
					goto handle_FriendUID

				case ffj_t_FriendCmdStruct_Message:
					goto handle_Message

				case ffj_t_FriendCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UID:

	/* handler: uj.UID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.UID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FriendUID:

	/* handler: uj.FriendUID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FriendUID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *InviteEmailStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InviteEmailStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"f_username":`)
	fflib.WriteJsonString(buf, string(mj.FromUsername))
	buf.WriteString(`,"emails":`)
	fflib.WriteJsonString(buf, string(mj.Emails))
	buf.WriteString(`,"phones":`)
	fflib.WriteJsonString(buf, string(mj.Phones))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InviteEmailStructbase = iota
	ffj_t_InviteEmailStructno_such_key

	ffj_t_InviteEmailStruct_Cmd

	ffj_t_InviteEmailStruct_FromUsername

	ffj_t_InviteEmailStruct_Emails

	ffj_t_InviteEmailStruct_Phones
)

var ffj_key_InviteEmailStruct_Cmd = []byte("cmd")

var ffj_key_InviteEmailStruct_FromUsername = []byte("f_username")

var ffj_key_InviteEmailStruct_Emails = []byte("emails")

var ffj_key_InviteEmailStruct_Phones = []byte("phones")

func (uj *InviteEmailStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InviteEmailStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InviteEmailStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InviteEmailStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_InviteEmailStruct_Cmd, kn) {
						currentKey = ffj_t_InviteEmailStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_InviteEmailStruct_Emails, kn) {
						currentKey = ffj_t_InviteEmailStruct_Emails
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_InviteEmailStruct_FromUsername, kn) {
						currentKey = ffj_t_InviteEmailStruct_FromUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_InviteEmailStruct_Phones, kn) {
						currentKey = ffj_t_InviteEmailStruct_Phones
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InviteEmailStruct_Phones, kn) {
					currentKey = ffj_t_InviteEmailStruct_Phones
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InviteEmailStruct_Emails, kn) {
					currentKey = ffj_t_InviteEmailStruct_Emails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InviteEmailStruct_FromUsername, kn) {
					currentKey = ffj_t_InviteEmailStruct_FromUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InviteEmailStruct_Cmd, kn) {
					currentKey = ffj_t_InviteEmailStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InviteEmailStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InviteEmailStruct_Cmd:
					goto handle_Cmd

				case ffj_t_InviteEmailStruct_FromUsername:
					goto handle_FromUsername

				case ffj_t_InviteEmailStruct_Emails:
					goto handle_Emails

				case ffj_t_InviteEmailStruct_Phones:
					goto handle_Phones

				case ffj_t_InviteEmailStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FromUsername:

	/* handler: uj.FromUsername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromUsername = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emails:

	/* handler: uj.Emails type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Emails = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phones:

	/* handler: uj.Phones type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Phones = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MatchUsersCmdEmailStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MatchUsersCmdEmailStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"Email":`)
	fflib.WriteJsonString(buf, string(mj.Email))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MatchUsersCmdEmailStructbase = iota
	ffj_t_MatchUsersCmdEmailStructno_such_key

	ffj_t_MatchUsersCmdEmailStruct_Name

	ffj_t_MatchUsersCmdEmailStruct_Email
)

var ffj_key_MatchUsersCmdEmailStruct_Name = []byte("Name")

var ffj_key_MatchUsersCmdEmailStruct_Email = []byte("Email")

func (uj *MatchUsersCmdEmailStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MatchUsersCmdEmailStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MatchUsersCmdEmailStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MatchUsersCmdEmailStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'E':

					if bytes.Equal(ffj_key_MatchUsersCmdEmailStruct_Email, kn) {
						currentKey = ffj_t_MatchUsersCmdEmailStruct_Email
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffj_key_MatchUsersCmdEmailStruct_Name, kn) {
						currentKey = ffj_t_MatchUsersCmdEmailStruct_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MatchUsersCmdEmailStruct_Email, kn) {
					currentKey = ffj_t_MatchUsersCmdEmailStruct_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MatchUsersCmdEmailStruct_Name, kn) {
					currentKey = ffj_t_MatchUsersCmdEmailStruct_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MatchUsersCmdEmailStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MatchUsersCmdEmailStruct_Name:
					goto handle_Name

				case ffj_t_MatchUsersCmdEmailStruct_Email:
					goto handle_Email

				case ffj_t_MatchUsersCmdEmailStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MatchUsersCmdPhoneStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MatchUsersCmdPhoneStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"PhoneNum":`)
	fflib.WriteJsonString(buf, string(mj.PhoneNum))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MatchUsersCmdPhoneStructbase = iota
	ffj_t_MatchUsersCmdPhoneStructno_such_key

	ffj_t_MatchUsersCmdPhoneStruct_Name

	ffj_t_MatchUsersCmdPhoneStruct_PhoneNum
)

var ffj_key_MatchUsersCmdPhoneStruct_Name = []byte("Name")

var ffj_key_MatchUsersCmdPhoneStruct_PhoneNum = []byte("PhoneNum")

func (uj *MatchUsersCmdPhoneStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MatchUsersCmdPhoneStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MatchUsersCmdPhoneStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MatchUsersCmdPhoneStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'N':

					if bytes.Equal(ffj_key_MatchUsersCmdPhoneStruct_Name, kn) {
						currentKey = ffj_t_MatchUsersCmdPhoneStruct_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_MatchUsersCmdPhoneStruct_PhoneNum, kn) {
						currentKey = ffj_t_MatchUsersCmdPhoneStruct_PhoneNum
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MatchUsersCmdPhoneStruct_PhoneNum, kn) {
					currentKey = ffj_t_MatchUsersCmdPhoneStruct_PhoneNum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MatchUsersCmdPhoneStruct_Name, kn) {
					currentKey = ffj_t_MatchUsersCmdPhoneStruct_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MatchUsersCmdPhoneStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MatchUsersCmdPhoneStruct_Name:
					goto handle_Name

				case ffj_t_MatchUsersCmdPhoneStruct_PhoneNum:
					goto handle_PhoneNum

				case ffj_t_MatchUsersCmdPhoneStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneNum:

	/* handler: uj.PhoneNum type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PhoneNum = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MatchUsersCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MatchUsersCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"Phones":`)
	if mj.Phones != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Phones {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Emails":`)
	if mj.Emails != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Emails {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MatchUsersCmdStructbase = iota
	ffj_t_MatchUsersCmdStructno_such_key

	ffj_t_MatchUsersCmdStruct_Cmd

	ffj_t_MatchUsersCmdStruct_Phones

	ffj_t_MatchUsersCmdStruct_Emails
)

var ffj_key_MatchUsersCmdStruct_Cmd = []byte("cmd")

var ffj_key_MatchUsersCmdStruct_Phones = []byte("Phones")

var ffj_key_MatchUsersCmdStruct_Emails = []byte("Emails")

func (uj *MatchUsersCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MatchUsersCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MatchUsersCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MatchUsersCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'E':

					if bytes.Equal(ffj_key_MatchUsersCmdStruct_Emails, kn) {
						currentKey = ffj_t_MatchUsersCmdStruct_Emails
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_MatchUsersCmdStruct_Phones, kn) {
						currentKey = ffj_t_MatchUsersCmdStruct_Phones
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_MatchUsersCmdStruct_Cmd, kn) {
						currentKey = ffj_t_MatchUsersCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MatchUsersCmdStruct_Emails, kn) {
					currentKey = ffj_t_MatchUsersCmdStruct_Emails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MatchUsersCmdStruct_Phones, kn) {
					currentKey = ffj_t_MatchUsersCmdStruct_Phones
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MatchUsersCmdStruct_Cmd, kn) {
					currentKey = ffj_t_MatchUsersCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MatchUsersCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MatchUsersCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_MatchUsersCmdStruct_Phones:
					goto handle_Phones

				case ffj_t_MatchUsersCmdStruct_Emails:
					goto handle_Emails

				case ffj_t_MatchUsersCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phones:

	/* handler: uj.Phones type=[]pcDatabase.MatchUsersCmdPhoneStruct kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Phones = nil
		} else {

			uj.Phones = make([]MatchUsersCmdPhoneStruct, 0)

			wantVal := true

			for {

				var v MatchUsersCmdPhoneStruct

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=pcDatabase.MatchUsersCmdPhoneStruct kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Phones = append(uj.Phones, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Emails:

	/* handler: uj.Emails type=[]pcDatabase.MatchUsersCmdEmailStruct kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Emails = nil
		} else {

			uj.Emails = make([]MatchUsersCmdEmailStruct, 0)

			wantVal := true

			for {

				var v MatchUsersCmdEmailStruct

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=pcDatabase.MatchUsersCmdEmailStruct kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Emails = append(uj.Emails, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MatchUsersReturnStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MatchUsersReturnStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"DisplayName":`)
	fflib.WriteJsonString(buf, string(mj.DisplayName))
	buf.WriteString(`,"ProfilePic":`)
	fflib.WriteJsonString(buf, string(mj.ProfilePic))
	buf.WriteString(`,"Phone":`)
	fflib.WriteJsonString(buf, string(mj.Phone))
	buf.WriteString(`,"Email":`)
	fflib.WriteJsonString(buf, string(mj.Email))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MatchUsersReturnStructbase = iota
	ffj_t_MatchUsersReturnStructno_such_key

	ffj_t_MatchUsersReturnStruct_Username

	ffj_t_MatchUsersReturnStruct_DisplayName

	ffj_t_MatchUsersReturnStruct_ProfilePic

	ffj_t_MatchUsersReturnStruct_Phone

	ffj_t_MatchUsersReturnStruct_Email
)

var ffj_key_MatchUsersReturnStruct_Username = []byte("Username")

var ffj_key_MatchUsersReturnStruct_DisplayName = []byte("DisplayName")

var ffj_key_MatchUsersReturnStruct_ProfilePic = []byte("ProfilePic")

var ffj_key_MatchUsersReturnStruct_Phone = []byte("Phone")

var ffj_key_MatchUsersReturnStruct_Email = []byte("Email")

func (uj *MatchUsersReturnStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MatchUsersReturnStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MatchUsersReturnStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MatchUsersReturnStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'D':

					if bytes.Equal(ffj_key_MatchUsersReturnStruct_DisplayName, kn) {
						currentKey = ffj_t_MatchUsersReturnStruct_DisplayName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffj_key_MatchUsersReturnStruct_Email, kn) {
						currentKey = ffj_t_MatchUsersReturnStruct_Email
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_MatchUsersReturnStruct_ProfilePic, kn) {
						currentKey = ffj_t_MatchUsersReturnStruct_ProfilePic
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MatchUsersReturnStruct_Phone, kn) {
						currentKey = ffj_t_MatchUsersReturnStruct_Phone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_MatchUsersReturnStruct_Username, kn) {
						currentKey = ffj_t_MatchUsersReturnStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MatchUsersReturnStruct_Email, kn) {
					currentKey = ffj_t_MatchUsersReturnStruct_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MatchUsersReturnStruct_Phone, kn) {
					currentKey = ffj_t_MatchUsersReturnStruct_Phone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MatchUsersReturnStruct_ProfilePic, kn) {
					currentKey = ffj_t_MatchUsersReturnStruct_ProfilePic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MatchUsersReturnStruct_DisplayName, kn) {
					currentKey = ffj_t_MatchUsersReturnStruct_DisplayName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MatchUsersReturnStruct_Username, kn) {
					currentKey = ffj_t_MatchUsersReturnStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MatchUsersReturnStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MatchUsersReturnStruct_Username:
					goto handle_Username

				case ffj_t_MatchUsersReturnStruct_DisplayName:
					goto handle_DisplayName

				case ffj_t_MatchUsersReturnStruct_ProfilePic:
					goto handle_ProfilePic

				case ffj_t_MatchUsersReturnStruct_Phone:
					goto handle_Phone

				case ffj_t_MatchUsersReturnStruct_Email:
					goto handle_Email

				case ffj_t_MatchUsersReturnStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisplayName:

	/* handler: uj.DisplayName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.DisplayName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfilePic:

	/* handler: uj.ProfilePic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProfilePic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phone:

	/* handler: uj.Phone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Phone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MessageStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MessageStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	if len(mj.CID) != 0 {
		buf.WriteString(`"CID":`)
		fflib.WriteJsonString(buf, string(mj.CID))
		buf.WriteByte(',')
	}
	if len(mj.FromUsername) != 0 {
		buf.WriteString(`"f_username":`)
		fflib.WriteJsonString(buf, string(mj.FromUsername))
		buf.WriteByte(',')
	}
	if len(mj.ToUIDs) != 0 {
		buf.WriteString(`"t_UIDs":`)
		if mj.ToUIDs != nil {
			buf.WriteString(`[`)
			for i, v := range mj.ToUIDs {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.M_time) != 0 {
		buf.WriteString(`"m_time":`)
		fflib.WriteJsonString(buf, string(mj.M_time))
		buf.WriteByte(',')
	}
	if len(mj.Content) != 0 {
		buf.WriteString(`"content":`)
		fflib.WriteJsonString(buf, string(mj.Content))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MessageStructbase = iota
	ffj_t_MessageStructno_such_key

	ffj_t_MessageStruct_Cmd

	ffj_t_MessageStruct_CID

	ffj_t_MessageStruct_FromUsername

	ffj_t_MessageStruct_ToUIDs

	ffj_t_MessageStruct_M_time

	ffj_t_MessageStruct_Content
)

var ffj_key_MessageStruct_Cmd = []byte("cmd")

var ffj_key_MessageStruct_CID = []byte("CID")

var ffj_key_MessageStruct_FromUsername = []byte("f_username")

var ffj_key_MessageStruct_ToUIDs = []byte("t_UIDs")

var ffj_key_MessageStruct_M_time = []byte("m_time")

var ffj_key_MessageStruct_Content = []byte("content")

func (uj *MessageStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MessageStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MessageStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MessageStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_MessageStruct_CID, kn) {
						currentKey = ffj_t_MessageStruct_CID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_MessageStruct_Cmd, kn) {
						currentKey = ffj_t_MessageStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageStruct_Content, kn) {
						currentKey = ffj_t_MessageStruct_Content
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_MessageStruct_FromUsername, kn) {
						currentKey = ffj_t_MessageStruct_FromUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MessageStruct_M_time, kn) {
						currentKey = ffj_t_MessageStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_MessageStruct_ToUIDs, kn) {
						currentKey = ffj_t_MessageStruct_ToUIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageStruct_Content, kn) {
					currentKey = ffj_t_MessageStruct_Content
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_MessageStruct_M_time, kn) {
					currentKey = ffj_t_MessageStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageStruct_ToUIDs, kn) {
					currentKey = ffj_t_MessageStruct_ToUIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageStruct_FromUsername, kn) {
					currentKey = ffj_t_MessageStruct_FromUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageStruct_CID, kn) {
					currentKey = ffj_t_MessageStruct_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageStruct_Cmd, kn) {
					currentKey = ffj_t_MessageStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MessageStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MessageStruct_Cmd:
					goto handle_Cmd

				case ffj_t_MessageStruct_CID:
					goto handle_CID

				case ffj_t_MessageStruct_FromUsername:
					goto handle_FromUsername

				case ffj_t_MessageStruct_ToUIDs:
					goto handle_ToUIDs

				case ffj_t_MessageStruct_M_time:
					goto handle_M_time

				case ffj_t_MessageStruct_Content:
					goto handle_Content

				case ffj_t_MessageStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FromUsername:

	/* handler: uj.FromUsername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromUsername = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ToUIDs:

	/* handler: uj.ToUIDs type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ToUIDs = nil
		} else {

			uj.ToUIDs = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.ToUIDs = append(uj.ToUIDs, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.M_time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: uj.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PasswordResetUserStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PasswordResetUserStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"Questions":`)
	if mj.Questions != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Questions {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Answers) != 0 {
		buf.WriteString(`"Answers":`)
		if mj.Answers != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Answers {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PasswordResetUserStructbase = iota
	ffj_t_PasswordResetUserStructno_such_key

	ffj_t_PasswordResetUserStruct_Cmd

	ffj_t_PasswordResetUserStruct_Username

	ffj_t_PasswordResetUserStruct_Questions

	ffj_t_PasswordResetUserStruct_Answers
)

var ffj_key_PasswordResetUserStruct_Cmd = []byte("cmd")

var ffj_key_PasswordResetUserStruct_Username = []byte("Username")

var ffj_key_PasswordResetUserStruct_Questions = []byte("Questions")

var ffj_key_PasswordResetUserStruct_Answers = []byte("Answers")

func (uj *PasswordResetUserStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PasswordResetUserStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PasswordResetUserStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PasswordResetUserStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_PasswordResetUserStruct_Answers, kn) {
						currentKey = ffj_t_PasswordResetUserStruct_Answers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffj_key_PasswordResetUserStruct_Questions, kn) {
						currentKey = ffj_t_PasswordResetUserStruct_Questions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_PasswordResetUserStruct_Username, kn) {
						currentKey = ffj_t_PasswordResetUserStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PasswordResetUserStruct_Cmd, kn) {
						currentKey = ffj_t_PasswordResetUserStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PasswordResetUserStruct_Answers, kn) {
					currentKey = ffj_t_PasswordResetUserStruct_Answers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PasswordResetUserStruct_Questions, kn) {
					currentKey = ffj_t_PasswordResetUserStruct_Questions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PasswordResetUserStruct_Username, kn) {
					currentKey = ffj_t_PasswordResetUserStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PasswordResetUserStruct_Cmd, kn) {
					currentKey = ffj_t_PasswordResetUserStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PasswordResetUserStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PasswordResetUserStruct_Cmd:
					goto handle_Cmd

				case ffj_t_PasswordResetUserStruct_Username:
					goto handle_Username

				case ffj_t_PasswordResetUserStruct_Questions:
					goto handle_Questions

				case ffj_t_PasswordResetUserStruct_Answers:
					goto handle_Answers

				case ffj_t_PasswordResetUserStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Questions:

	/* handler: uj.Questions type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Questions = nil
		} else {

			uj.Questions = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Questions = append(uj.Questions, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Answers:

	/* handler: uj.Answers type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Answers = nil
		} else {

			uj.Answers = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Answers = append(uj.Answers, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *QuotaCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *QuotaCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"Quota":`)
	fflib.FormatBits2(buf, uint64(mj.Quota), 10, false)
	buf.WriteString(`,"QuotaUsed":`)
	fflib.FormatBits2(buf, uint64(mj.QuotaUsed), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_QuotaCmdStructbase = iota
	ffj_t_QuotaCmdStructno_such_key

	ffj_t_QuotaCmdStruct_Cmd

	ffj_t_QuotaCmdStruct_Username

	ffj_t_QuotaCmdStruct_Quota

	ffj_t_QuotaCmdStruct_QuotaUsed
)

var ffj_key_QuotaCmdStruct_Cmd = []byte("cmd")

var ffj_key_QuotaCmdStruct_Username = []byte("Username")

var ffj_key_QuotaCmdStruct_Quota = []byte("Quota")

var ffj_key_QuotaCmdStruct_QuotaUsed = []byte("QuotaUsed")

func (uj *QuotaCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *QuotaCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_QuotaCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_QuotaCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'Q':

					if bytes.Equal(ffj_key_QuotaCmdStruct_Quota, kn) {
						currentKey = ffj_t_QuotaCmdStruct_Quota
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_QuotaCmdStruct_QuotaUsed, kn) {
						currentKey = ffj_t_QuotaCmdStruct_QuotaUsed
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_QuotaCmdStruct_Username, kn) {
						currentKey = ffj_t_QuotaCmdStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_QuotaCmdStruct_Cmd, kn) {
						currentKey = ffj_t_QuotaCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_QuotaCmdStruct_QuotaUsed, kn) {
					currentKey = ffj_t_QuotaCmdStruct_QuotaUsed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_QuotaCmdStruct_Quota, kn) {
					currentKey = ffj_t_QuotaCmdStruct_Quota
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_QuotaCmdStruct_Username, kn) {
					currentKey = ffj_t_QuotaCmdStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_QuotaCmdStruct_Cmd, kn) {
					currentKey = ffj_t_QuotaCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_QuotaCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_QuotaCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_QuotaCmdStruct_Username:
					goto handle_Username

				case ffj_t_QuotaCmdStruct_Quota:
					goto handle_Quota

				case ffj_t_QuotaCmdStruct_QuotaUsed:
					goto handle_QuotaUsed

				case ffj_t_QuotaCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quota:

	/* handler: uj.Quota type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Quota = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_QuotaUsed:

	/* handler: uj.QuotaUsed type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.QuotaUsed = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ScheduledMessagesCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ScheduledMessagesCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"CID":`)
	fflib.WriteJsonString(buf, string(mj.CID))
	buf.WriteString(`,"Time":`)
	fflib.WriteJsonString(buf, string(mj.Time))
	buf.WriteString(`,"Content":`)
	fflib.WriteJsonString(buf, string(mj.Content))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ScheduledMessagesCmdStructbase = iota
	ffj_t_ScheduledMessagesCmdStructno_such_key

	ffj_t_ScheduledMessagesCmdStruct_Cmd

	ffj_t_ScheduledMessagesCmdStruct_Username

	ffj_t_ScheduledMessagesCmdStruct_CID

	ffj_t_ScheduledMessagesCmdStruct_Time

	ffj_t_ScheduledMessagesCmdStruct_Content
)

var ffj_key_ScheduledMessagesCmdStruct_Cmd = []byte("cmd")

var ffj_key_ScheduledMessagesCmdStruct_Username = []byte("Username")

var ffj_key_ScheduledMessagesCmdStruct_CID = []byte("CID")

var ffj_key_ScheduledMessagesCmdStruct_Time = []byte("Time")

var ffj_key_ScheduledMessagesCmdStruct_Content = []byte("Content")

func (uj *ScheduledMessagesCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ScheduledMessagesCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ScheduledMessagesCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ScheduledMessagesCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_ScheduledMessagesCmdStruct_CID, kn) {
						currentKey = ffj_t_ScheduledMessagesCmdStruct_CID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ScheduledMessagesCmdStruct_Content, kn) {
						currentKey = ffj_t_ScheduledMessagesCmdStruct_Content
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_ScheduledMessagesCmdStruct_Time, kn) {
						currentKey = ffj_t_ScheduledMessagesCmdStruct_Time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_ScheduledMessagesCmdStruct_Username, kn) {
						currentKey = ffj_t_ScheduledMessagesCmdStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_ScheduledMessagesCmdStruct_Cmd, kn) {
						currentKey = ffj_t_ScheduledMessagesCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ScheduledMessagesCmdStruct_Content, kn) {
					currentKey = ffj_t_ScheduledMessagesCmdStruct_Content
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ScheduledMessagesCmdStruct_Time, kn) {
					currentKey = ffj_t_ScheduledMessagesCmdStruct_Time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ScheduledMessagesCmdStruct_CID, kn) {
					currentKey = ffj_t_ScheduledMessagesCmdStruct_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ScheduledMessagesCmdStruct_Username, kn) {
					currentKey = ffj_t_ScheduledMessagesCmdStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ScheduledMessagesCmdStruct_Cmd, kn) {
					currentKey = ffj_t_ScheduledMessagesCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ScheduledMessagesCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ScheduledMessagesCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_ScheduledMessagesCmdStruct_Username:
					goto handle_Username

				case ffj_t_ScheduledMessagesCmdStruct_CID:
					goto handle_CID

				case ffj_t_ScheduledMessagesCmdStruct_Time:
					goto handle_Time

				case ffj_t_ScheduledMessagesCmdStruct_Content:
					goto handle_Content

				case ffj_t_ScheduledMessagesCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Time:

	/* handler: uj.Time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: uj.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ScheduledMessagesStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ScheduledMessagesStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"CID":`)
	fflib.WriteJsonString(buf, string(mj.CID))
	buf.WriteString(`,"Time":`)
	fflib.WriteJsonString(buf, string(mj.Time))
	buf.WriteString(`,"Content":`)
	fflib.WriteJsonString(buf, string(mj.Content))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ScheduledMessagesStructbase = iota
	ffj_t_ScheduledMessagesStructno_such_key

	ffj_t_ScheduledMessagesStruct_CID

	ffj_t_ScheduledMessagesStruct_Time

	ffj_t_ScheduledMessagesStruct_Content
)

var ffj_key_ScheduledMessagesStruct_CID = []byte("CID")

var ffj_key_ScheduledMessagesStruct_Time = []byte("Time")

var ffj_key_ScheduledMessagesStruct_Content = []byte("Content")

func (uj *ScheduledMessagesStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ScheduledMessagesStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ScheduledMessagesStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ScheduledMessagesStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffj_key_ScheduledMessagesStruct_CID, kn) {
						currentKey = ffj_t_ScheduledMessagesStruct_CID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ScheduledMessagesStruct_Content, kn) {
						currentKey = ffj_t_ScheduledMessagesStruct_Content
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_ScheduledMessagesStruct_Time, kn) {
						currentKey = ffj_t_ScheduledMessagesStruct_Time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ScheduledMessagesStruct_Content, kn) {
					currentKey = ffj_t_ScheduledMessagesStruct_Content
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ScheduledMessagesStruct_Time, kn) {
					currentKey = ffj_t_ScheduledMessagesStruct_Time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ScheduledMessagesStruct_CID, kn) {
					currentKey = ffj_t_ScheduledMessagesStruct_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ScheduledMessagesStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ScheduledMessagesStruct_CID:
					goto handle_CID

				case ffj_t_ScheduledMessagesStruct_Time:
					goto handle_Time

				case ffj_t_ScheduledMessagesStruct_Content:
					goto handle_Content

				case ffj_t_ScheduledMessagesStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Time:

	/* handler: uj.Time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: uj.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SecurityQuestionStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SecurityQuestionStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Question":`)
	fflib.WriteJsonString(buf, string(mj.Question))
	buf.WriteString(`,"Answer":`)
	fflib.WriteJsonString(buf, string(mj.Answer))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SecurityQuestionStructbase = iota
	ffj_t_SecurityQuestionStructno_such_key

	ffj_t_SecurityQuestionStruct_Question

	ffj_t_SecurityQuestionStruct_Answer
)

var ffj_key_SecurityQuestionStruct_Question = []byte("Question")

var ffj_key_SecurityQuestionStruct_Answer = []byte("Answer")

func (uj *SecurityQuestionStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SecurityQuestionStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SecurityQuestionStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SecurityQuestionStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_SecurityQuestionStruct_Answer, kn) {
						currentKey = ffj_t_SecurityQuestionStruct_Answer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffj_key_SecurityQuestionStruct_Question, kn) {
						currentKey = ffj_t_SecurityQuestionStruct_Question
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_SecurityQuestionStruct_Answer, kn) {
					currentKey = ffj_t_SecurityQuestionStruct_Answer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SecurityQuestionStruct_Question, kn) {
					currentKey = ffj_t_SecurityQuestionStruct_Question
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SecurityQuestionStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SecurityQuestionStruct_Question:
					goto handle_Question

				case ffj_t_SecurityQuestionStruct_Answer:
					goto handle_Answer

				case ffj_t_SecurityQuestionStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Question:

	/* handler: uj.Question type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Question = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Answer:

	/* handler: uj.Answer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Answer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SendEmailAttachment) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SendEmailAttachment) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"FileType":`)
	fflib.WriteJsonString(buf, string(mj.FileType))
	buf.WriteString(`,"FileName":`)
	fflib.WriteJsonString(buf, string(mj.FileName))
	buf.WriteString(`,"Binary":`)
	fflib.WriteJsonString(buf, string(mj.Binary))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SendEmailAttachmentbase = iota
	ffj_t_SendEmailAttachmentno_such_key

	ffj_t_SendEmailAttachment_FileType

	ffj_t_SendEmailAttachment_FileName

	ffj_t_SendEmailAttachment_Binary
)

var ffj_key_SendEmailAttachment_FileType = []byte("FileType")

var ffj_key_SendEmailAttachment_FileName = []byte("FileName")

var ffj_key_SendEmailAttachment_Binary = []byte("Binary")

func (uj *SendEmailAttachment) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SendEmailAttachment) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SendEmailAttachmentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SendEmailAttachmentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'B':

					if bytes.Equal(ffj_key_SendEmailAttachment_Binary, kn) {
						currentKey = ffj_t_SendEmailAttachment_Binary
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_SendEmailAttachment_FileType, kn) {
						currentKey = ffj_t_SendEmailAttachment_FileType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_SendEmailAttachment_FileName, kn) {
						currentKey = ffj_t_SendEmailAttachment_FileName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_SendEmailAttachment_Binary, kn) {
					currentKey = ffj_t_SendEmailAttachment_Binary
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SendEmailAttachment_FileName, kn) {
					currentKey = ffj_t_SendEmailAttachment_FileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SendEmailAttachment_FileType, kn) {
					currentKey = ffj_t_SendEmailAttachment_FileType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SendEmailAttachmentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SendEmailAttachment_FileType:
					goto handle_FileType

				case ffj_t_SendEmailAttachment_FileName:
					goto handle_FileName

				case ffj_t_SendEmailAttachment_Binary:
					goto handle_Binary

				case ffj_t_SendEmailAttachmentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileType:

	/* handler: uj.FileType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: uj.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Binary:

	/* handler: uj.Binary type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Binary = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SendEmailCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SendEmailCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"FromEmail":`)
	fflib.WriteJsonString(buf, string(mj.FromEmail))
	buf.WriteString(`,"ToEmails":`)
	if mj.ToEmails != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ToEmails {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Subject":`)
	fflib.WriteJsonString(buf, string(mj.Subject))
	buf.WriteString(`,"Content":`)
	fflib.WriteJsonString(buf, string(mj.Content))
	buf.WriteString(`,"Attachments":`)
	if mj.Attachments != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Attachments {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"M_time":`)
	fflib.WriteJsonString(buf, string(mj.M_time))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SendEmailCmdStructbase = iota
	ffj_t_SendEmailCmdStructno_such_key

	ffj_t_SendEmailCmdStruct_Cmd

	ffj_t_SendEmailCmdStruct_FromEmail

	ffj_t_SendEmailCmdStruct_ToEmails

	ffj_t_SendEmailCmdStruct_Subject

	ffj_t_SendEmailCmdStruct_Content

	ffj_t_SendEmailCmdStruct_Attachments

	ffj_t_SendEmailCmdStruct_M_time
)

var ffj_key_SendEmailCmdStruct_Cmd = []byte("cmd")

var ffj_key_SendEmailCmdStruct_FromEmail = []byte("FromEmail")

var ffj_key_SendEmailCmdStruct_ToEmails = []byte("ToEmails")

var ffj_key_SendEmailCmdStruct_Subject = []byte("Subject")

var ffj_key_SendEmailCmdStruct_Content = []byte("Content")

var ffj_key_SendEmailCmdStruct_Attachments = []byte("Attachments")

var ffj_key_SendEmailCmdStruct_M_time = []byte("M_time")

func (uj *SendEmailCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SendEmailCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SendEmailCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SendEmailCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_SendEmailCmdStruct_Attachments, kn) {
						currentKey = ffj_t_SendEmailCmdStruct_Attachments
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_SendEmailCmdStruct_Content, kn) {
						currentKey = ffj_t_SendEmailCmdStruct_Content
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_SendEmailCmdStruct_FromEmail, kn) {
						currentKey = ffj_t_SendEmailCmdStruct_FromEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_SendEmailCmdStruct_M_time, kn) {
						currentKey = ffj_t_SendEmailCmdStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_SendEmailCmdStruct_Subject, kn) {
						currentKey = ffj_t_SendEmailCmdStruct_Subject
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_SendEmailCmdStruct_ToEmails, kn) {
						currentKey = ffj_t_SendEmailCmdStruct_ToEmails
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_SendEmailCmdStruct_Cmd, kn) {
						currentKey = ffj_t_SendEmailCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_SendEmailCmdStruct_M_time, kn) {
					currentKey = ffj_t_SendEmailCmdStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SendEmailCmdStruct_Attachments, kn) {
					currentKey = ffj_t_SendEmailCmdStruct_Attachments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SendEmailCmdStruct_Content, kn) {
					currentKey = ffj_t_SendEmailCmdStruct_Content
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SendEmailCmdStruct_Subject, kn) {
					currentKey = ffj_t_SendEmailCmdStruct_Subject
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SendEmailCmdStruct_ToEmails, kn) {
					currentKey = ffj_t_SendEmailCmdStruct_ToEmails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SendEmailCmdStruct_FromEmail, kn) {
					currentKey = ffj_t_SendEmailCmdStruct_FromEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SendEmailCmdStruct_Cmd, kn) {
					currentKey = ffj_t_SendEmailCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SendEmailCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SendEmailCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_SendEmailCmdStruct_FromEmail:
					goto handle_FromEmail

				case ffj_t_SendEmailCmdStruct_ToEmails:
					goto handle_ToEmails

				case ffj_t_SendEmailCmdStruct_Subject:
					goto handle_Subject

				case ffj_t_SendEmailCmdStruct_Content:
					goto handle_Content

				case ffj_t_SendEmailCmdStruct_Attachments:
					goto handle_Attachments

				case ffj_t_SendEmailCmdStruct_M_time:
					goto handle_M_time

				case ffj_t_SendEmailCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FromEmail:

	/* handler: uj.FromEmail type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromEmail = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ToEmails:

	/* handler: uj.ToEmails type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ToEmails = nil
		} else {

			uj.ToEmails = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.ToEmails = append(uj.ToEmails, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Subject:

	/* handler: uj.Subject type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Subject = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: uj.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attachments:

	/* handler: uj.Attachments type=[]pcDatabase.SendEmailAttachment kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Attachments = nil
		} else {

			uj.Attachments = make([]SendEmailAttachment, 0)

			wantVal := true

			for {

				var v SendEmailAttachment

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=pcDatabase.SendEmailAttachment kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Attachments = append(uj.Attachments, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.M_time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UpdateEmailCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UpdateEmailCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"FromEmail":`)
	fflib.WriteJsonString(buf, string(mj.FromEmail))
	buf.WriteString(`,"ToEmails":`)
	if mj.ToEmails != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ToEmails {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Subject":`)
	fflib.WriteJsonString(buf, string(mj.Subject))
	buf.WriteString(`,"Attachments":`)
	if mj.Attachments != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Attachments {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Content":`)
	fflib.WriteJsonString(buf, string(mj.Content))
	buf.WriteString(`,"RecvTime":`)
	fflib.WriteJsonString(buf, string(mj.RecvTime))
	buf.WriteString(`,"EmailMtime":`)
	fflib.WriteJsonString(buf, string(mj.EmailMtime))
	if mj.Unread {
		buf.WriteString(`,"Unread":true`)
	} else {
		buf.WriteString(`,"Unread":false`)
	}
	if mj.Spam {
		buf.WriteString(`,"Spam":true`)
	} else {
		buf.WriteString(`,"Spam":false`)
	}
	if mj.Starred {
		buf.WriteString(`,"Starred":true`)
	} else {
		buf.WriteString(`,"Starred":false`)
	}
	if mj.Deleted {
		buf.WriteString(`,"Deleted":true`)
	} else {
		buf.WriteString(`,"Deleted":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UpdateEmailCmdStructbase = iota
	ffj_t_UpdateEmailCmdStructno_such_key

	ffj_t_UpdateEmailCmdStruct_Cmd

	ffj_t_UpdateEmailCmdStruct_Username

	ffj_t_UpdateEmailCmdStruct_FromEmail

	ffj_t_UpdateEmailCmdStruct_ToEmails

	ffj_t_UpdateEmailCmdStruct_Subject

	ffj_t_UpdateEmailCmdStruct_Attachments

	ffj_t_UpdateEmailCmdStruct_Content

	ffj_t_UpdateEmailCmdStruct_RecvTime

	ffj_t_UpdateEmailCmdStruct_EmailMtime

	ffj_t_UpdateEmailCmdStruct_Unread

	ffj_t_UpdateEmailCmdStruct_Spam

	ffj_t_UpdateEmailCmdStruct_Starred

	ffj_t_UpdateEmailCmdStruct_Deleted
)

var ffj_key_UpdateEmailCmdStruct_Cmd = []byte("cmd")

var ffj_key_UpdateEmailCmdStruct_Username = []byte("Username")

var ffj_key_UpdateEmailCmdStruct_FromEmail = []byte("FromEmail")

var ffj_key_UpdateEmailCmdStruct_ToEmails = []byte("ToEmails")

var ffj_key_UpdateEmailCmdStruct_Subject = []byte("Subject")

var ffj_key_UpdateEmailCmdStruct_Attachments = []byte("Attachments")

var ffj_key_UpdateEmailCmdStruct_Content = []byte("Content")

var ffj_key_UpdateEmailCmdStruct_RecvTime = []byte("RecvTime")

var ffj_key_UpdateEmailCmdStruct_EmailMtime = []byte("EmailMtime")

var ffj_key_UpdateEmailCmdStruct_Unread = []byte("Unread")

var ffj_key_UpdateEmailCmdStruct_Spam = []byte("Spam")

var ffj_key_UpdateEmailCmdStruct_Starred = []byte("Starred")

var ffj_key_UpdateEmailCmdStruct_Deleted = []byte("Deleted")

func (uj *UpdateEmailCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UpdateEmailCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UpdateEmailCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UpdateEmailCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Attachments, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Attachments
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Content, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Content
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Deleted, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Deleted
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_EmailMtime, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_EmailMtime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_FromEmail, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_FromEmail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_RecvTime, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_RecvTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Subject, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Subject
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Spam, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Spam
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Starred, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Starred
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_ToEmails, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_ToEmails
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Username, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Unread, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Unread
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_UpdateEmailCmdStruct_Cmd, kn) {
						currentKey = ffj_t_UpdateEmailCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UpdateEmailCmdStruct_Deleted, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Deleted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UpdateEmailCmdStruct_Starred, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Starred
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UpdateEmailCmdStruct_Spam, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Spam
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UpdateEmailCmdStruct_Unread, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Unread
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UpdateEmailCmdStruct_EmailMtime, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_EmailMtime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UpdateEmailCmdStruct_RecvTime, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_RecvTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UpdateEmailCmdStruct_Content, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Content
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UpdateEmailCmdStruct_Attachments, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Attachments
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UpdateEmailCmdStruct_Subject, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Subject
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UpdateEmailCmdStruct_ToEmails, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_ToEmails
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UpdateEmailCmdStruct_FromEmail, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_FromEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UpdateEmailCmdStruct_Username, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UpdateEmailCmdStruct_Cmd, kn) {
					currentKey = ffj_t_UpdateEmailCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UpdateEmailCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UpdateEmailCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_UpdateEmailCmdStruct_Username:
					goto handle_Username

				case ffj_t_UpdateEmailCmdStruct_FromEmail:
					goto handle_FromEmail

				case ffj_t_UpdateEmailCmdStruct_ToEmails:
					goto handle_ToEmails

				case ffj_t_UpdateEmailCmdStruct_Subject:
					goto handle_Subject

				case ffj_t_UpdateEmailCmdStruct_Attachments:
					goto handle_Attachments

				case ffj_t_UpdateEmailCmdStruct_Content:
					goto handle_Content

				case ffj_t_UpdateEmailCmdStruct_RecvTime:
					goto handle_RecvTime

				case ffj_t_UpdateEmailCmdStruct_EmailMtime:
					goto handle_EmailMtime

				case ffj_t_UpdateEmailCmdStruct_Unread:
					goto handle_Unread

				case ffj_t_UpdateEmailCmdStruct_Spam:
					goto handle_Spam

				case ffj_t_UpdateEmailCmdStruct_Starred:
					goto handle_Starred

				case ffj_t_UpdateEmailCmdStruct_Deleted:
					goto handle_Deleted

				case ffj_t_UpdateEmailCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FromEmail:

	/* handler: uj.FromEmail type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FromEmail = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ToEmails:

	/* handler: uj.ToEmails type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ToEmails = nil
		} else {

			uj.ToEmails = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.ToEmails = append(uj.ToEmails, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Subject:

	/* handler: uj.Subject type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Subject = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Attachments:

	/* handler: uj.Attachments type=[]pcDatabase.SendEmailAttachment kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Attachments = nil
		} else {

			uj.Attachments = make([]SendEmailAttachment, 0)

			wantVal := true

			for {

				var v SendEmailAttachment

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=pcDatabase.SendEmailAttachment kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Attachments = append(uj.Attachments, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Content:

	/* handler: uj.Content type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Content = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RecvTime:

	/* handler: uj.RecvTime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.RecvTime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmailMtime:

	/* handler: uj.EmailMtime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.EmailMtime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unread:

	/* handler: uj.Unread type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Unread = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Unread = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spam:

	/* handler: uj.Spam type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Spam = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Spam = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Starred:

	/* handler: uj.Starred type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Starred = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Starred = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Deleted:

	/* handler: uj.Deleted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Deleted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Deleted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserCIDStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserCIDStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"CID":`)
	fflib.WriteJsonString(buf, string(mj.CID))
	buf.WriteString(`,"M_time":`)
	fflib.WriteJsonString(buf, string(mj.M_time))
	buf.WriteString(`,"UnreadCount":`)
	fflib.FormatBits2(buf, uint64(mj.UnreadCount), 10, mj.UnreadCount < 0)
	buf.WriteString(`,"AutoreplySent":`)
	fflib.FormatBits2(buf, uint64(mj.AutoreplySent), 10, mj.AutoreplySent < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserCIDStructbase = iota
	ffj_t_UserCIDStructno_such_key

	ffj_t_UserCIDStruct_CID

	ffj_t_UserCIDStruct_M_time

	ffj_t_UserCIDStruct_UnreadCount

	ffj_t_UserCIDStruct_AutoreplySent
)

var ffj_key_UserCIDStruct_CID = []byte("CID")

var ffj_key_UserCIDStruct_M_time = []byte("M_time")

var ffj_key_UserCIDStruct_UnreadCount = []byte("UnreadCount")

var ffj_key_UserCIDStruct_AutoreplySent = []byte("AutoreplySent")

func (uj *UserCIDStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserCIDStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserCIDStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserCIDStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_UserCIDStruct_AutoreplySent, kn) {
						currentKey = ffj_t_UserCIDStruct_AutoreplySent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_UserCIDStruct_CID, kn) {
						currentKey = ffj_t_UserCIDStruct_CID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffj_key_UserCIDStruct_M_time, kn) {
						currentKey = ffj_t_UserCIDStruct_M_time
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_UserCIDStruct_UnreadCount, kn) {
						currentKey = ffj_t_UserCIDStruct_UnreadCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_UserCIDStruct_AutoreplySent, kn) {
					currentKey = ffj_t_UserCIDStruct_AutoreplySent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserCIDStruct_UnreadCount, kn) {
					currentKey = ffj_t_UserCIDStruct_UnreadCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_UserCIDStruct_M_time, kn) {
					currentKey = ffj_t_UserCIDStruct_M_time
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserCIDStruct_CID, kn) {
					currentKey = ffj_t_UserCIDStruct_CID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserCIDStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserCIDStruct_CID:
					goto handle_CID

				case ffj_t_UserCIDStruct_M_time:
					goto handle_M_time

				case ffj_t_UserCIDStruct_UnreadCount:
					goto handle_UnreadCount

				case ffj_t_UserCIDStruct_AutoreplySent:
					goto handle_AutoreplySent

				case ffj_t_UserCIDStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CID:

	/* handler: uj.CID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_M_time:

	/* handler: uj.M_time type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.M_time = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UnreadCount:

	/* handler: uj.UnreadCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.UnreadCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AutoreplySent:

	/* handler: uj.AutoreplySent type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AutoreplySent = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserFriendStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserFriendStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"ProfilePic":`)
	fflib.WriteJsonString(buf, string(mj.ProfilePic))
	buf.WriteString(`,"Message":`)
	fflib.WriteJsonString(buf, string(mj.Message))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserFriendStructbase = iota
	ffj_t_UserFriendStructno_such_key

	ffj_t_UserFriendStruct_Username

	ffj_t_UserFriendStruct_ProfilePic

	ffj_t_UserFriendStruct_Message
)

var ffj_key_UserFriendStruct_Username = []byte("Username")

var ffj_key_UserFriendStruct_ProfilePic = []byte("ProfilePic")

var ffj_key_UserFriendStruct_Message = []byte("Message")

func (uj *UserFriendStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserFriendStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserFriendStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserFriendStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'M':

					if bytes.Equal(ffj_key_UserFriendStruct_Message, kn) {
						currentKey = ffj_t_UserFriendStruct_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_UserFriendStruct_ProfilePic, kn) {
						currentKey = ffj_t_UserFriendStruct_ProfilePic
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_UserFriendStruct_Username, kn) {
						currentKey = ffj_t_UserFriendStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_UserFriendStruct_Message, kn) {
					currentKey = ffj_t_UserFriendStruct_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserFriendStruct_ProfilePic, kn) {
					currentKey = ffj_t_UserFriendStruct_ProfilePic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserFriendStruct_Username, kn) {
					currentKey = ffj_t_UserFriendStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserFriendStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserFriendStruct_Username:
					goto handle_Username

				case ffj_t_UserFriendStruct_ProfilePic:
					goto handle_ProfilePic

				case ffj_t_UserFriendStruct_Message:
					goto handle_Message

				case ffj_t_UserFriendStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfilePic:

	/* handler: uj.ProfilePic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProfilePic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Message = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "Username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteString(`,"UsernameUpper":`)
	fflib.WriteJsonString(buf, string(mj.UsernameUpper))
	buf.WriteString(`,"Password":`)
	fflib.WriteJsonString(buf, string(mj.Password))
	buf.WriteString(`,"Email":`)
	fflib.WriteJsonString(buf, string(mj.Email))
	buf.WriteString(`,"Phone":`)
	fflib.WriteJsonString(buf, string(mj.Phone))
	buf.WriteString(`,"PhoneGateway":`)
	fflib.WriteJsonString(buf, string(mj.PhoneGateway))
	buf.WriteString(`,"AutoreplyMessage":`)
	fflib.WriteJsonString(buf, string(mj.AutoreplyMessage))
	buf.WriteString(`,"Friends":`)
	fflib.WriteJsonString(buf, string(mj.Friends))
	buf.WriteString(`,"IncomingPendingFriends":`)
	fflib.WriteJsonString(buf, string(mj.IncomingPendingFriends))
	buf.WriteString(`,"OutgoingPendingFriends":`)
	fflib.WriteJsonString(buf, string(mj.OutgoingPendingFriends))
	buf.WriteString(`,"CIDs":`)
	fflib.WriteJsonString(buf, string(mj.CIDs))
	buf.WriteString(`,"ScheduledMessages":`)
	fflib.WriteJsonString(buf, string(mj.ScheduledMessages))
	buf.WriteString(`,"EmailMtime":`)
	fflib.WriteJsonString(buf, string(mj.EmailMtime))
	buf.WriteString(`,"Android":`)
	if mj.Android != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Android {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Fireos":`)
	if mj.Fireos != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Fireos {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Ios":`)
	if mj.Ios != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Ios {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Web":`)
	if mj.Web != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Web {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"ProfilePic":`)
	fflib.WriteJsonString(buf, string(mj.ProfilePic))
	buf.WriteString(`,"Quota":`)
	fflib.FormatBits2(buf, uint64(mj.Quota), 10, false)
	buf.WriteString(`,"QuotaUsed":`)
	fflib.FormatBits2(buf, uint64(mj.QuotaUsed), 10, false)
	buf.WriteString(`,"SecQuests":`)
	fflib.WriteJsonString(buf, string(mj.SecQuests))
	buf.WriteByte(',')
	if len(mj.Cmd) != 0 {
		buf.WriteString(`"cmd":`)
		fflib.WriteJsonString(buf, string(mj.Cmd))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserStructbase = iota
	ffj_t_UserStructno_such_key

	ffj_t_UserStruct_Username

	ffj_t_UserStruct_UsernameUpper

	ffj_t_UserStruct_Password

	ffj_t_UserStruct_Email

	ffj_t_UserStruct_Phone

	ffj_t_UserStruct_PhoneGateway

	ffj_t_UserStruct_AutoreplyMessage

	ffj_t_UserStruct_Friends

	ffj_t_UserStruct_IncomingPendingFriends

	ffj_t_UserStruct_OutgoingPendingFriends

	ffj_t_UserStruct_CIDs

	ffj_t_UserStruct_ScheduledMessages

	ffj_t_UserStruct_EmailMtime

	ffj_t_UserStruct_Android

	ffj_t_UserStruct_Fireos

	ffj_t_UserStruct_Ios

	ffj_t_UserStruct_Web

	ffj_t_UserStruct_ProfilePic

	ffj_t_UserStruct_Quota

	ffj_t_UserStruct_QuotaUsed

	ffj_t_UserStruct_SecQuests

	ffj_t_UserStruct_Cmd
)

var ffj_key_UserStruct_Username = []byte("Username")

var ffj_key_UserStruct_UsernameUpper = []byte("UsernameUpper")

var ffj_key_UserStruct_Password = []byte("Password")

var ffj_key_UserStruct_Email = []byte("Email")

var ffj_key_UserStruct_Phone = []byte("Phone")

var ffj_key_UserStruct_PhoneGateway = []byte("PhoneGateway")

var ffj_key_UserStruct_AutoreplyMessage = []byte("AutoreplyMessage")

var ffj_key_UserStruct_Friends = []byte("Friends")

var ffj_key_UserStruct_IncomingPendingFriends = []byte("IncomingPendingFriends")

var ffj_key_UserStruct_OutgoingPendingFriends = []byte("OutgoingPendingFriends")

var ffj_key_UserStruct_CIDs = []byte("CIDs")

var ffj_key_UserStruct_ScheduledMessages = []byte("ScheduledMessages")

var ffj_key_UserStruct_EmailMtime = []byte("EmailMtime")

var ffj_key_UserStruct_Android = []byte("Android")

var ffj_key_UserStruct_Fireos = []byte("Fireos")

var ffj_key_UserStruct_Ios = []byte("Ios")

var ffj_key_UserStruct_Web = []byte("Web")

var ffj_key_UserStruct_ProfilePic = []byte("ProfilePic")

var ffj_key_UserStruct_Quota = []byte("Quota")

var ffj_key_UserStruct_QuotaUsed = []byte("QuotaUsed")

var ffj_key_UserStruct_SecQuests = []byte("SecQuests")

var ffj_key_UserStruct_Cmd = []byte("cmd")

func (uj *UserStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffj_key_UserStruct_AutoreplyMessage, kn) {
						currentKey = ffj_t_UserStruct_AutoreplyMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_Android, kn) {
						currentKey = ffj_t_UserStruct_Android
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffj_key_UserStruct_CIDs, kn) {
						currentKey = ffj_t_UserStruct_CIDs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffj_key_UserStruct_Email, kn) {
						currentKey = ffj_t_UserStruct_Email
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_EmailMtime, kn) {
						currentKey = ffj_t_UserStruct_EmailMtime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_UserStruct_Friends, kn) {
						currentKey = ffj_t_UserStruct_Friends
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_Fireos, kn) {
						currentKey = ffj_t_UserStruct_Fireos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffj_key_UserStruct_IncomingPendingFriends, kn) {
						currentKey = ffj_t_UserStruct_IncomingPendingFriends
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_Ios, kn) {
						currentKey = ffj_t_UserStruct_Ios
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'O':

					if bytes.Equal(ffj_key_UserStruct_OutgoingPendingFriends, kn) {
						currentKey = ffj_t_UserStruct_OutgoingPendingFriends
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffj_key_UserStruct_Password, kn) {
						currentKey = ffj_t_UserStruct_Password
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_Phone, kn) {
						currentKey = ffj_t_UserStruct_Phone
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_PhoneGateway, kn) {
						currentKey = ffj_t_UserStruct_PhoneGateway
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_ProfilePic, kn) {
						currentKey = ffj_t_UserStruct_ProfilePic
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Q':

					if bytes.Equal(ffj_key_UserStruct_Quota, kn) {
						currentKey = ffj_t_UserStruct_Quota
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_QuotaUsed, kn) {
						currentKey = ffj_t_UserStruct_QuotaUsed
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffj_key_UserStruct_ScheduledMessages, kn) {
						currentKey = ffj_t_UserStruct_ScheduledMessages
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_SecQuests, kn) {
						currentKey = ffj_t_UserStruct_SecQuests
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'U':

					if bytes.Equal(ffj_key_UserStruct_Username, kn) {
						currentKey = ffj_t_UserStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserStruct_UsernameUpper, kn) {
						currentKey = ffj_t_UserStruct_UsernameUpper
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'W':

					if bytes.Equal(ffj_key_UserStruct_Web, kn) {
						currentKey = ffj_t_UserStruct_Web
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_UserStruct_Cmd, kn) {
						currentKey = ffj_t_UserStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_Cmd, kn) {
					currentKey = ffj_t_UserStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_SecQuests, kn) {
					currentKey = ffj_t_UserStruct_SecQuests
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_QuotaUsed, kn) {
					currentKey = ffj_t_UserStruct_QuotaUsed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_Quota, kn) {
					currentKey = ffj_t_UserStruct_Quota
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_ProfilePic, kn) {
					currentKey = ffj_t_UserStruct_ProfilePic
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_Web, kn) {
					currentKey = ffj_t_UserStruct_Web
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_Ios, kn) {
					currentKey = ffj_t_UserStruct_Ios
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_Fireos, kn) {
					currentKey = ffj_t_UserStruct_Fireos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_Android, kn) {
					currentKey = ffj_t_UserStruct_Android
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_EmailMtime, kn) {
					currentKey = ffj_t_UserStruct_EmailMtime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_ScheduledMessages, kn) {
					currentKey = ffj_t_UserStruct_ScheduledMessages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_CIDs, kn) {
					currentKey = ffj_t_UserStruct_CIDs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_OutgoingPendingFriends, kn) {
					currentKey = ffj_t_UserStruct_OutgoingPendingFriends
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_IncomingPendingFriends, kn) {
					currentKey = ffj_t_UserStruct_IncomingPendingFriends
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_Friends, kn) {
					currentKey = ffj_t_UserStruct_Friends
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_AutoreplyMessage, kn) {
					currentKey = ffj_t_UserStruct_AutoreplyMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_PhoneGateway, kn) {
					currentKey = ffj_t_UserStruct_PhoneGateway
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_Phone, kn) {
					currentKey = ffj_t_UserStruct_Phone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserStruct_Email, kn) {
					currentKey = ffj_t_UserStruct_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_Password, kn) {
					currentKey = ffj_t_UserStruct_Password
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_UsernameUpper, kn) {
					currentKey = ffj_t_UserStruct_UsernameUpper
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserStruct_Username, kn) {
					currentKey = ffj_t_UserStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserStruct_Username:
					goto handle_Username

				case ffj_t_UserStruct_UsernameUpper:
					goto handle_UsernameUpper

				case ffj_t_UserStruct_Password:
					goto handle_Password

				case ffj_t_UserStruct_Email:
					goto handle_Email

				case ffj_t_UserStruct_Phone:
					goto handle_Phone

				case ffj_t_UserStruct_PhoneGateway:
					goto handle_PhoneGateway

				case ffj_t_UserStruct_AutoreplyMessage:
					goto handle_AutoreplyMessage

				case ffj_t_UserStruct_Friends:
					goto handle_Friends

				case ffj_t_UserStruct_IncomingPendingFriends:
					goto handle_IncomingPendingFriends

				case ffj_t_UserStruct_OutgoingPendingFriends:
					goto handle_OutgoingPendingFriends

				case ffj_t_UserStruct_CIDs:
					goto handle_CIDs

				case ffj_t_UserStruct_ScheduledMessages:
					goto handle_ScheduledMessages

				case ffj_t_UserStruct_EmailMtime:
					goto handle_EmailMtime

				case ffj_t_UserStruct_Android:
					goto handle_Android

				case ffj_t_UserStruct_Fireos:
					goto handle_Fireos

				case ffj_t_UserStruct_Ios:
					goto handle_Ios

				case ffj_t_UserStruct_Web:
					goto handle_Web

				case ffj_t_UserStruct_ProfilePic:
					goto handle_ProfilePic

				case ffj_t_UserStruct_Quota:
					goto handle_Quota

				case ffj_t_UserStruct_QuotaUsed:
					goto handle_QuotaUsed

				case ffj_t_UserStruct_SecQuests:
					goto handle_SecQuests

				case ffj_t_UserStruct_Cmd:
					goto handle_Cmd

				case ffj_t_UserStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UsernameUpper:

	/* handler: uj.UsernameUpper type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.UsernameUpper = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Password:

	/* handler: uj.Password type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Password = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Email = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phone:

	/* handler: uj.Phone type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Phone = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhoneGateway:

	/* handler: uj.PhoneGateway type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PhoneGateway = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AutoreplyMessage:

	/* handler: uj.AutoreplyMessage type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.AutoreplyMessage = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Friends:

	/* handler: uj.Friends type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Friends = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IncomingPendingFriends:

	/* handler: uj.IncomingPendingFriends type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.IncomingPendingFriends = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OutgoingPendingFriends:

	/* handler: uj.OutgoingPendingFriends type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.OutgoingPendingFriends = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CIDs:

	/* handler: uj.CIDs type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CIDs = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ScheduledMessages:

	/* handler: uj.ScheduledMessages type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ScheduledMessages = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmailMtime:

	/* handler: uj.EmailMtime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.EmailMtime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Android:

	/* handler: uj.Android type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Android = nil
		} else {

			uj.Android = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Android = append(uj.Android, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fireos:

	/* handler: uj.Fireos type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Fireos = nil
		} else {

			uj.Fireos = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Fireos = append(uj.Fireos, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ios:

	/* handler: uj.Ios type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Ios = nil
		} else {

			uj.Ios = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Ios = append(uj.Ios, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Web:

	/* handler: uj.Web type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Web = nil
		} else {

			uj.Web = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						v = string(string(outBuf))

					}
				}

				uj.Web = append(uj.Web, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProfilePic:

	/* handler: uj.ProfilePic type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ProfilePic = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Quota:

	/* handler: uj.Quota type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Quota = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_QuotaUsed:

	/* handler: uj.QuotaUsed type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.QuotaUsed = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SecQuests:

	/* handler: uj.SecQuests type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.SecQuests = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ValidateUserCmdStruct) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ValidateUserCmdStruct) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"cmd":`)
	fflib.WriteJsonString(buf, string(mj.Cmd))
	buf.WriteString(`,"password":`)
	fflib.WriteJsonString(buf, string(mj.Password))
	buf.WriteString(`,"token":`)
	fflib.WriteJsonString(buf, string(mj.Token))
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(mj.Username))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ValidateUserCmdStructbase = iota
	ffj_t_ValidateUserCmdStructno_such_key

	ffj_t_ValidateUserCmdStruct_Cmd

	ffj_t_ValidateUserCmdStruct_Password

	ffj_t_ValidateUserCmdStruct_Token

	ffj_t_ValidateUserCmdStruct_Username
)

var ffj_key_ValidateUserCmdStruct_Cmd = []byte("cmd")

var ffj_key_ValidateUserCmdStruct_Password = []byte("password")

var ffj_key_ValidateUserCmdStruct_Token = []byte("token")

var ffj_key_ValidateUserCmdStruct_Username = []byte("username")

func (uj *ValidateUserCmdStruct) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ValidateUserCmdStruct) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ValidateUserCmdStructbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ValidateUserCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ValidateUserCmdStruct_Cmd, kn) {
						currentKey = ffj_t_ValidateUserCmdStruct_Cmd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ValidateUserCmdStruct_Password, kn) {
						currentKey = ffj_t_ValidateUserCmdStruct_Password
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ValidateUserCmdStruct_Token, kn) {
						currentKey = ffj_t_ValidateUserCmdStruct_Token
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ValidateUserCmdStruct_Username, kn) {
						currentKey = ffj_t_ValidateUserCmdStruct_Username
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ValidateUserCmdStruct_Username, kn) {
					currentKey = ffj_t_ValidateUserCmdStruct_Username
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ValidateUserCmdStruct_Token, kn) {
					currentKey = ffj_t_ValidateUserCmdStruct_Token
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ValidateUserCmdStruct_Password, kn) {
					currentKey = ffj_t_ValidateUserCmdStruct_Password
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ValidateUserCmdStruct_Cmd, kn) {
					currentKey = ffj_t_ValidateUserCmdStruct_Cmd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ValidateUserCmdStructno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ValidateUserCmdStruct_Cmd:
					goto handle_Cmd

				case ffj_t_ValidateUserCmdStruct_Password:
					goto handle_Password

				case ffj_t_ValidateUserCmdStruct_Token:
					goto handle_Token

				case ffj_t_ValidateUserCmdStruct_Username:
					goto handle_Username

				case ffj_t_ValidateUserCmdStructno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Cmd:

	/* handler: uj.Cmd type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Cmd = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Password:

	/* handler: uj.Password type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Password = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Token:

	/* handler: uj.Token type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Token = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Username:

	/* handler: uj.Username type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Username = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
